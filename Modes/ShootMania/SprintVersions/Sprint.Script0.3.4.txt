/****************************************
*	SprintCup Game Mode					*
*	Author: 	steeffeen				*
*	Contact:	schteffens@gmail.com	*
****************************************/

/* TODO:
- checkpoint ranking
*/

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const	CompatibleMapTypes	"SprintArena,SprintCupArena,TimeAttackArena"
#Const	Version				"0.3.4 (2013-05-31)"
#Const	ScriptName			"Sprint.Script.txt"

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Chrono.Script.txt" as Chronos
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/ShootMania/AFK.Script.txt" as AFK
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/ScoresTable.Script.txt" as ScoresTable
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen

// SETTINGS
#Setting	S_PointsLimit			125		as _("Points Limit")
#Setting	S_RaceFinishLimit		15		as _("Time limit to end the Race after the first player finished")
#Setting	S_WarmUpRounds			1		as _("Number of WarmUp rounds per Map")
#Setting	S_EnablePvP				False	as _("Enable PvP Weapons")

#Setting	S_RoundTimeLimit		600		as "<hidden>"

// CONSTANTS
#Const		C_PointsList			[25, 18, 15, 12, 10, 8, 6, 4, 2, 1]	// Points granted for the specific ranks
#Const		C_ChronoPosition		<50., -73.>		// Position of the chrono
#Const		C_SpeedoMeterPosition	<-49., -73.>	// Position of speedometer
#Const		C_RankingsListLength	10				// Length of rankings list
#Const		C_RankingsListPosition	<-157., 47.>	// Position of rankings list and warmup label

#Const		Description				_("$<$oObjective:$> Beat your Opponents in fast neck-and-neck races.")

// GLOBALES
declare Integer			G_RankListReset;	// Time when the rankings list needs to be cleared
declare Boolean			G_WarmUp;			// Whether it's currently warmup
declare Integer			G_MapRound;			// Number of the round on the current map
declare Integer			G_CheckpointsCount;	// Number of checkpoints on the current map
declare Ident[]			G_StartedPlayers;	// Ids of currently racing players
declare Integer[Ident]	G_FinishedPlayers;	// Times of finished players
declare Boolean			Old_EnablePvP;		// Cache for enable pvp
declare Integer			Old_PointsLimit;	// Cache for points limit

// EXTEND
***LogVersion***
***
MB_LogVersion(ScriptName, Version);
MB_LogVersion(Interface::GetScriptName(), Interface::GetScriptVersion());
MB_LogVersion(Message::GetScriptName(), Message::GetScriptVersion());
MB_LogVersion(Score::GetScriptName(), Score::GetScriptVersion());
MB_LogVersion(ScoresTable::GetScriptName(), ScoresTable::GetScriptVersion());
MB_LogVersion(SM::GetScriptName(), SM::GetScriptVersion());
MB_LogVersion(SpawnScreen::GetScriptName(), SpawnScreen::GetScriptVersion());
***

***ModeStatusMessage***
***
declare Text Message;
declare Base = "%1 (%2)\n$<$o%4:$> $<%5$>";
if (UseClans) {
	declare Score = "$<"^Teams[0].ColorizedName^"$> "^ClanScores[0]^" : "^ClanScores[1]^" $<"^Teams[1].ColorizedName^"$>";
	Message = TextLib::Compose(Base, Description, _("Team"), _("|Headline score|Current Score"), Score);
} else {
	declare Leading = "";
	declare Leader = "";
	if (Scores.existskey(0)) {
		Leading = _("|Headline leading player|Leading");
		Leader = Scores[0].User.Name;
	}
	Message = TextLib::Compose(Base, Description, _("Solo"), Leading, Leader);
}
This.ModeStatusMessage = Message;
***

***StartServer***
***
// Set mode options
This.UsePvPCollisions = False;
This.UsePvPWeapons = S_EnablePvP;
This.UseClans = False;
MB_UseSectionRound = True;

Old_EnablePvP = S_EnablePvP;
Old_PointsLimit = S_PointsLimit;

// UI
---ModeStatusMessage---
SM::SetupDefaultVisibility();
SpawnScreen::CreateRules(TextLib::Split(".", ScriptName)[0], _("\nYou must finish the Races as fast as possible.\n\nEach Race grants Points for the best Players.\nThe Player who reaches the Point Limit first wins the Map."));
SpawnScreen::CreateMapInfo();
SpawnScreen::CreateScores();
Interface::CreateRank();

ScoresTable::Load();
ScoresTable::SetTableFormat(2, 6);
ScoresTable::SetTableBackgroundImage("file://Media/Manialinks/ShootMania/Common/topsBg.dds", <0.05, 56.>, <207., 178.>);
ScoresTable::SetColumnsWidth(2.5, 1.5, 2.5, 15., 1.7, 1.7, 0.5, 3.5, 0.5, 0., 4.);
ScoresTable::SetColumnName("Custom2", _("|Name for best value|Best"));
ScoresTable::SetColumnName("Points", _("Points"));
ScoresTable::SetDefaultCustom2("-:--.--");
ScoresTable::SetScoreFormat("$o");
ScoresTable::SetDefaultFooterScore(" ");
ScoresTable::SetDefaultFooterStats(TextLib::Compose(_(" Points Limit: %1"), TextLib::ToText(S_PointsLimit)));
ScoresTable::Build();

declare MarkersLayer <=> UIManager.UILayerCreate();
MarkersLayer.Type = CUILayer::EUILayerType::Markers;
UIManager.UIAll.UILayers.add(MarkersLayer);

declare ExtrasLayer <=> UIManager.UILayerCreate();
ExtrasLayer.ManialinkPage = GetExtrasLayerManialink();
UIManager.UIAll.UILayers.add(ExtrasLayer);

declare RankingsLayer <=> UIManager.UILayerCreate();
RankingsLayer.ManialinkPage = GetRankingsLayerManialink();
UIManager.UIAll.UILayers.add(RankingsLayer);
***

***StartMap***
***
// New map message
Message::CleanAllMessages();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;

// Prepare map
foreach (Base in Bases) {
	Base.Clan = 0;
	Base.IsActive = True;
}
G_CheckpointsCount = 0;
foreach (Pole in BlockPoles) {
	Pole.Gauge.ValueReal = 1.0;
	Pole.Captured = True;
	switch (Pole.Tag) {
		case "Checkpoint": {
			if (Pole.Order < 0) continue;
			G_CheckpointsCount += 1;
		}	
	}
}
{
	declare netwrite Integer Net_G_CheckpointsCount for Teams[0];
	Net_G_CheckpointsCount = G_CheckpointsCount;
}

// Wait for players to join
while (AllPlayers.count <= 0) {
	yield;
}

// Begin map
foreach (Player in AllPlayers) {
	InitPlayer(Player, True);
}

Score::MatchBegin();
Score::RoundBegin();
ScoresTable::StartMatch();
foreach (Player in AllPlayers) {
	ScoresTable::SetCustom2(Player, "");
}
G_WarmUp = True;
G_MapRound = 0;

ExtrasLayer.IsVisible = True;
UIManager.UIAll.Hud3dMarkers = GetHud3dMarkers();
MarkersLayer.ManialinkPage = GetMarkersManialink();
MarkersLayer.IsVisible = True;
RankingsLayer.IsVisible = True;
Interface::AttachRank();
***

***StartRound***
***
G_StartedPlayers.clear();
G_FinishedPlayers.clear();

G_MapRound += 1;
G_WarmUp = (G_MapRound <= S_WarmUpRounds && S_WarmUpRounds > 0);
{
	declare netwrite Text Net_RemainingWarmUp for Teams[0];
	if (G_WarmUp) {
		Net_RemainingWarmUp = G_MapRound^"/"^S_WarmUpRounds;
	} else {
		Net_RemainingWarmUp = "";
	}
}
Message::CleanBigMessages();
if (G_MapRound == S_WarmUpRounds+1 || (S_WarmUpRounds < 0 && G_MapRound == 1)) {
	Message::SendBigMessage(_("Match Start!"), 2000, 2, CUIConfig::EUISound::StartRound, 0);
}

G_RankListReset = Now + 2500;
UIManager.UIAll.OverlayHideCountdown = True;
This.StartTime = Now + 3000;
This.EndTime = -1;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
UpdateExtrasLayer();
***

***OnNewPlayer***
***
InitPlayer(Player, False);
ScoresTable::RestoreCustomScores(Player);
***

***OnNewSpectator***
***
InitPlayer(Spectator, False);
ScoresTable::RestoreCustomScores(Spectator);
***

***PlayLoop***
***
if (G_RankListReset > 0 && This.Now >= G_RankListReset) {
	G_RankListReset = -1;
	foreach (Player in AllPlayers) {
		declare netwrite Integer Net_CurrentTime for Player;
		Net_CurrentTime = -1;
	}
}
CheckScriptSettings();
AFK::ManageAFKPlayers();
Message::Loop();
UpdateExtrasLayer();

// Update settings
if (Old_PointsLimit != S_PointsLimit) {
	Old_PointsLimit = S_PointsLimit;
	declare Message = TextLib::Compose(_(" Points Limit: %1"), TextLib::ToText(S_PointsLimit));
	foreach (Player in AllPlayers) {
		ScoresTable::SetFooterStats(Player, Message);
	}
}

// Manage events
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnArmorEmpty: {
			RestartPlayer(Event.Victim, True, Now+3000);
			Discard(Event);
		}
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
			RestartPlayer(Event.Player, True, Now+3000);
			Discard(Event);
		}
		case CSmModeEvent::EType::OnHit: {
			Discard(Event);
		}
		default: {
			PassOn(Event);
		}
	}
}

// Manage players
foreach (Player in Players) {
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			if (G_StartedPlayers.exists(Player.Id)) continue;
			if (G_FinishedPlayers.existskey(Player.Id)) continue;
			RestartPlayer(Player, False, StartTime);
		}
		case CSmPlayer::ESpawnStatus::Spawned: {
			if (Player.BlockPole == Null) continue;
			if (Player.BlockPole.Order < 0) continue;
			declare CheckpointsTimes for Player = Integer[Ident];
			switch (Player.BlockPole.Tag) {
				case "Checkpoint": {
					ActivateCheckpoint(Player, Player.BlockPole.Id);
				}
				case "Goal": {
					ActivateFinish(Player);
				}
			}
		}
	}
}

// Round end conditions
if (This.EndTime > 0 && This.Now >= This.EndTime + 400
	|| This.Now - This.StartTime > S_RoundTimeLimit * 1000
	|| G_StartedPlayers.count > 0 && (PlayersNbAlive == 0 || G_FinishedPlayers.count >= G_StartedPlayers.count)) {
	MB_StopRound = True;
	if (This.Now - This.StartTime > S_RoundTimeLimit * 1000) {
		Message::SendStatusMessage(_("Time is up!"), 2000, 0);
	}
}
***

***EndRound***
***
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
// Determine and announce round winner
declare RaceWinnerId = NullId;
declare RaceWinTime = -1;
foreach (PlayerId => RunTime in G_FinishedPlayers) {
	if (RaceWinnerId == NullId || RunTime < RaceWinTime) {
		RaceWinnerId = PlayerId;
		RaceWinTime = RunTime;
	}
}
if (!G_WarmUp && Players.existskey(RaceWinnerId)) {
	Message::SendBigMessage(TextLib::Compose(_("$<%1$> wins the Round!"), Players[RaceWinnerId].Name), 3000, 1);
}
MB_Sleep(1500);
UIManager.UIAll.OverlayHideCountdown = True;
This.EndTime = -1;
This.StartTime = -1;
UpdateExtrasLayer();
// Match end conditions
foreach (Score in Scores) {
	if (Score.Points >= S_PointsLimit) {
		MB_StopMap = True;
	}
}
if (AllPlayers.count <= 0) {
	// Server is empty - Next map to start WarmUp
	MB_StopMap = True;
}
if (!MB_StopMap) {
	SM::UnspawnAllPlayers();
}
MB_Sleep(2500);
***

***EndMap***
***
Score::RoundEnd();
Score::MatchEnd();
ScoresTable::EndMatch();

ExtrasLayer.IsVisible = False;
MarkersLayer.IsVisible = False;
RankingsLayer.IsVisible = False;
Interface::DetachRank();

// Determine and announce winner
declare CSmScore Winner <=> Null;
foreach (Score in Scores) {
	declare BestRunTime as BestRunTimeWinner for Winner = -1;
	declare BestRunTime as BestRunTimeThis for Score = -1;
	if (Score.Points > 0 && (Winner == Null || Score.Points > Winner.Points ||
		(Score.Points == Winner.Points && BestRunTimeThis < BestRunTimeWinner))) {
		Winner <=> Score;
	}
}

declare Message = _("|Match|Draw");
if (Winner != Null && Winner.User != Null) {
	Message = TextLib::Compose(_("$<%1$> wins the Match!"), Winner.User.Name);
}
Message::SendBigMessage(Message, 5000, 2);
MB_Sleep(3000);

UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
MB_Sleep(5000);
***

***EndServer***
***
ScoresTable::Unload();
Interface::DestroyRank();
SpawnScreen::DestroyRules();
SpawnScreen::DestroyMapInfo();
SpawnScreen::DestroyScores();
UIManager.UILayerDestroyAll();
***

// FUNCTIONS

// Check for changes of script settings
Void CheckScriptSettings() {
	// Check enable pvp
	if (This.UsePvPWeapons != S_EnablePvP) {
		This.UsePvPWeapons = S_EnablePvP;
		Old_EnablePvP = S_EnablePvP;
		declare Color = "$0f0";
		declare Status = "";
		if (!UsePvPWeapons) {
			Color = "$f00";
			Status = "de";
		}
		UIManager.UIAll.SendChat("Info>>$<$f80PvP Weapons$> are now $<"^Color^Status^"activated$>!");
	}
}

// Determine CPSpawn for checkpoint respawns
Ident GetCPSpawnId(CSmPlayer _Player) {
	if (_Player == Null) return NullId;
	declare LastCheckPointId for _Player = NullId;
	if (!BlockPoles.existskey(LastCheckPointId)) return NullId;
	declare SpawnId = NullId;
	declare CPPole <=> BlockPoles[LastCheckPointId];
	if (CPPole.Order != 0) {
		// Find assigned CPSpawn
		foreach (Spawn in BlockSpawns) {
			switch (Spawn.Tag) {
				case "CPSpawn": {
					if (Spawn.Order == CPPole.Order) {
						return Spawn.Id;
					}
				}
			}
		}
	}
	// No specific CPSpawn assigned, determine closest one
	declare Distance = -1.;
	foreach (Spawn in BlockSpawns) {
		switch (Spawn.Tag) {
			case "CPSpawn": {
				if (Spawn.Order > CPPole.Order) continue;
				declare SpawnDistance = MathLib::Distance(Spawn.Position, CPPole.Position);
				if (SpawnDistance < Distance || Distance < 0) {
					SpawnId = Spawn.Id;
					Distance = SpawnDistance;
				}
			}
		}
	}
	return SpawnId;
}

// Initialize the player
Void InitPlayer(CSmPlayer _Player, Boolean _Full) {
	if (_Player == Null) return;
	
	declare Ident LastCheckPointId for _Player;
	declare Integer[Ident] CheckpointsTimes for _Player;
	LastCheckPointId = NullId;
	CheckpointsTimes.clear();
	
	declare Temp = G_StartedPlayers.remove(_Player.Id);
	Temp = G_FinishedPlayers.removekey(_Player.Id);
	
	if (!_Full || _Player.Score == Null) return;
	
	declare Integer BestRunTime for _Player.Score;
	BestRunTime = -1;
}

// Update footer score for given player
Void UpdateFooterScore(CSmPlayer _Player) {
	if (_Player == Null) return;
	
	if (G_FinishedPlayers.existskey(_Player.Id)) {
		ScoresTable::SetFooterScore(_Player, TextLib::Compose(_("Race Rank: %1/%2"),
			TextLib::ToText(G_FinishedPlayers.count), TextLib::ToText(G_StartedPlayers.count)));
	} else {
		declare CheckpointsTimes for _Player = Integer[Ident];
		ScoresTable::SetFooterScore(_Player, TextLib::Compose(_("|Progress on checkpoints|Progress: CP %1/%2"),
			TextLib::ToText(CheckpointsTimes.count), TextLib::ToText(G_CheckpointsCount)));
	}
}

// Restart a player
Void RestartPlayer(CSmPlayer _Player, Boolean _UseCPSpawns, Integer _StartTime) {
	if (_Player == Null) return;
	UnspawnPlayer(_Player);
	if (_Player.RequestsSpectate) return;
	
	declare Clan = 0;
	if (UseClans) {
		Clan = _Player.RequestedClan;
	}
	
	if (_StartTime != This.StartTime) {
		UIManager.UIAll.SendNotice(TextLib::Compose(_("$<%1$> respawned!"), _Player.Name),
			CUIConfig::ENoticeLevel::PlayerInfo, _Player.User, CUIConfig::EAvatarVariant::Default,
			CUIConfig::EUISound::Silence, 0);
	}
	
	if (_UseCPSpawns) {
		declare CPSpawnId = GetCPSpawnId(_Player);
		if (BlockSpawns.existskey(CPSpawnId)) {
			SM::SpawnPlayer(_Player, Clan, BlockSpawns[CPSpawnId], _StartTime);
			return;
		}
	}
	
	declare Ident LastCheckPointId for _Player;
	declare CheckpointsTimes for _Player = Integer[Ident];
	LastCheckPointId = NullId;
	CheckpointsTimes.clear();
	
	declare netwrite Integer Net_CheckpointsCount for _Player;
	Net_CheckpointsCount = CheckpointsTimes.count;
	
	if (!G_StartedPlayers.exists(_Player.Id)) {
		G_StartedPlayers.add(_Player.Id);
	}
	UpdateFooterScore(_Player);
	
	SM::SpawnPlayer(_Player, Clan, SM::GetSpawn("Spawn", 0), _StartTime);
}

// A player reaches a checkpoint
Void ActivateCheckpoint(CSmPlayer _Player, Ident _CheckpointId) {
	if (_Player == Null) return;
	if (!BlockPoles.existskey(_CheckpointId)) return;
	
	declare CheckpointsTimes for _Player = Integer[Ident];
	if (CheckpointsTimes.existskey(_CheckpointId)) return;
	if (BlockPoles[_CheckpointId].Order != 0 && BlockPoles[_CheckpointId].Order != CheckpointsTimes.count+1) {
		declare LastStatusMessage for _Player = 0;
		if (LastStatusMessage + 3000 < This.Now) {
			LastStatusMessage = This.Now;
			Message::SendStatusMessage(_Player, _("Wrong Checkpoint!"), 3000, 1);
		}
		return;
	}
	
	declare Ident LastCheckPointId for _Player;
	LastCheckPointId = _CheckpointId;
	CheckpointsTimes[_CheckpointId] = This.Now;
	
	declare netwrite Integer Net_CheckpointsCount for _Player;
	Net_CheckpointsCount = CheckpointsTimes.count;
	UpdateFooterScore(_Player);
	
	declare UI <=> UIManager.GetUI(_Player);
	if (UI != Null) {
		UI.SendNotice(TextLib::Compose(_("Checkpoint %1/%2: %3"),
			TextLib::ToText(CheckpointsTimes.count), TextLib::ToText(G_CheckpointsCount),
			TextLib::TimeToText(This.Now - This.StartTime, True)),
			CUIConfig::ENoticeLevel::MapInfo, _Player.User, CUIConfig::EAvatarVariant::Default,
			CUIConfig::EUISound::Checkpoint, CheckpointsTimes.count);
	}
}

// Calculate race points depending on finished players
Integer GetFinishPoints(Integer _Rank) {
	if (G_WarmUp || !C_PointsList.existskey(_Rank - 1)) return 0;
	return C_PointsList[_Rank - 1];
}

// A player reaches the goal
Void ActivateFinish(CSmPlayer _Player) {
	if (_Player == Null) return;
	if (G_FinishedPlayers.existskey(_Player.Id)) return;
	
	declare CheckpointsTimes for _Player = Integer[Ident];
	if (CheckpointsTimes.count < G_CheckpointsCount) {
		declare LastStatusMessage for _Player = 0;
		if (LastStatusMessage + 3000 < This.Now) {
			LastStatusMessage = This.Now;
			declare Extra = "";
			if (G_CheckpointsCount-CheckpointsTimes.count > 1) {
				Extra = "s";
			}
			Message::SendStatusMessage(_Player, TextLib::Compose(_("%1You missed %2 Checkpoint%3!"),
				"$f00", TextLib::ToText(G_CheckpointsCount-CheckpointsTimes.count), Extra), 3000, 1);
		}
		return;
	}
	
	declare netwrite Integer Net_CheckpointsCount for _Player;
	Net_CheckpointsCount = 0;
	
	declare RunTime = This.Now - This.StartTime;
	
	if (_Player.Score != Null && !G_WarmUp) {
		_Player.Score.Points += GetFinishPoints(G_FinishedPlayers.count+1);
		declare BestRunTime for _Player.Score = -1;
		if (RunTime < BestRunTime || BestRunTime < 0) {
			BestRunTime = RunTime;
			ScoresTable::SetCustom2(_Player, TextLib::TimeToText(RunTime, True));
		}
	}
	
	G_FinishedPlayers[_Player.Id] = RunTime;
	if (G_FinishedPlayers.count == 1) {
		foreach (PlayerId in G_StartedPlayers) {
			if (G_FinishedPlayers.existskey(PlayerId) || !Players.existskey(PlayerId)) continue;
			Message::SendStatusMessage(Players[PlayerId], _("Hurry!"), 4000, 0);
		}
	}
	
	declare netwrite Integer Net_CurrentTime for _Player;
	Net_CurrentTime = RunTime;
	UpdateFooterScore(_Player);

	if (MB_UseScriptCallbacks) {
		XmlRpc.SendCallback("Finished", """{"Login":"{{{_Player.Login}}}", "Score":{{{RunTime}}}}""");
	}
	declare UI <=> UIManager.GetUI(_Player);
	if (UI != Null) {
		UI.SendNotice(TextLib::Compose(_("Finish: %1"), TextLib::TimeToText(RunTime, True)),
			CUIConfig::ENoticeLevel::MatchInfo, _Player.User, CUIConfig::EAvatarVariant::Default,
			CUIConfig::EUISound::Finish, 0);
	}
	
	if (EndTime < 0) {
		EndTime = This.Now + S_RaceFinishLimit * 1000;
		UIManager.UIAll.OverlayHideCountdown = False;
	}
	
	UnspawnPlayer(_Player);
}

// Create hud3dmarkers
Text GetHud3dMarkers() {
	declare Markers = "";
	foreach (Pole in BlockPoles) {
		Markers ^= """<marker pos="{{{Pole.Position[0]}}} {{{Pole.Position[1]}}} {{{Pole.Position[2]}}}" box="0 4 0"
			manialinkframeid="Frame_Pole{{{Pole.Id}}}" visibility="WhenInFrustum"/>""";
	}
	return Markers;
}

// Create manialink for markers layer
Text GetMarkersManialink() {
	declare Manialink = """<script><!--
	#Include "TextLib" as TextLib
	
	declare CMlFrame[] G_Frame_Poles;
	
	Void ShowMarkerForPole(Ident _PoleId, Boolean _Goal) {
		declare Frame_Pole <=> (Page.GetFirstChild("Frame_Pole"^_PoleId) as CMlFrame);
		Frame_Pole.Visible = True;
		foreach (Control in Frame_Pole.Controls) {
			Control.Visible = True;
		}
		declare Label_NextCP <=> (Frame_Pole.GetFirstChild("Label_NextCP") as CMlLabel);
		if (_Goal) {
			Label_NextCP.Value = _("Finish");
		} else {
			Label_NextCP.Value = TextLib::Compose(_("|Checkpoint No.|CP %1"),
				TextLib::ToText(BlockPoles[_PoleId].Order));
		}
		G_Frame_Poles.add(Frame_Pole);
	}
	
	Void HideFrames(CMlFrame[] _Frames) {
		foreach (Frame in _Frames) {
			Frame.Visible = False;
			foreach (Control in Frame.Controls) {
				Control.Visible = False;
			}
		}
	}
	
	main() {
		declare netread Net_G_CheckpointsCount for Teams[0] = -1;
		declare Old_CheckpointsCount = -2;
		
		while (True) {
			yield;
			
			if (InputPlayer == Null) continue;
			
			declare LocalPlayer <=> InputPlayer;
			if (IsSpectatorMode && GUIPlayer == Null) {
				HideFrames(G_Frame_Poles);
				G_Frame_Poles.clear();
				continue;
			}
			if (GUIPlayer != Null) LocalPlayer <=> GUIPlayer;
			
			declare netread Net_CheckpointsCount for LocalPlayer = -1;
			if (Old_CheckpointsCount == Net_CheckpointsCount) continue;
			Old_CheckpointsCount = Net_CheckpointsCount;
			
			HideFrames(G_Frame_Poles);
			G_Frame_Poles.clear();
			
			if (Net_CheckpointsCount == Net_G_CheckpointsCount) {
				foreach (Pole in BlockPoles) {
					switch (Pole.Tag) {
						case "Goal": {
							ShowMarkerForPole(Pole.Id, True);
						}
					}
				}
			} else {
				foreach (Pole in BlockPoles) {
					if (Pole.Order == Net_CheckpointsCount+1) {
						ShowMarkerForPole(Pole.Id, False);
						break;
					}
				}
			}
		}
	}
	--></script>
	<framemodel id="FrameModel_Pole">
		<label id="Label_NextCP" textprefix="$o" textsize="2" hidden="1" halign="center" valign="center2"/>
		<quad posn="0 -1.5" sizen="4 4" opacity="0.85" halign="center" valign="top" hidden="1"
			image="http://www.team-devota.com/steeffeen/images/MarkerArrowDown.png"/>
	</framemodel>""";
	foreach (Pole in BlockPoles) {
		Manialink ^= """<frameinstance modelid="FrameModel_Pole" id="Frame_Pole{{{Pole.Id}}}" hidden="1"/>""";
	}
	return Manialink;
}

// Create manialink for extras layer
Text GetExtrasLayerManialink() {
	declare WarmUpFlagWidth = 0.5;
	return """<script><!--
		#Include "MathLib" as MathLib
		#Include "TextLib" as TextLib
		
		Real Round(Real _Value) {
			return MathLib::NearestInteger(_Value * 10.) / 10.;
		}
		
		main() {
			declare Frame_WarmUp		<=> (Page.GetFirstChild("Frame_WarmUp") as CMlFrame);
			declare Label_WarmUp		<=> (Frame_WarmUp.GetFirstChild("Label_WarmUp") as CMlLabel);
			
			declare Frame_Chrono		<=> (Page.GetFirstChild("Frame_Chrono") as CMlFrame);
			declare Label_Chrono		<=> (Frame_Chrono.GetFirstChild("Label_Chrono") as CMlLabel);
			
			declare Frame_SpeedoMeter	<=> (Page.GetFirstChild("Frame_SpeedoMeter") as CMlFrame);
			declare Label_Speed			<=> (Frame_SpeedoMeter.GetFirstChild("Label_Speed") as CMlLabel);
			
			declare netread Net_RemainingWarmUp for Teams[0] = "";
			declare Old_RemainingWarmUp = "";
			
			declare netread Net_StartTime for Teams[0] = -1;
			declare LastStartTime = -1;
			
			declare Vec3 LastPosition;
			declare LastPositionTime = -1;
			declare LastSpeed = -1.;
			
			while (True) {
				yield;
				
				if (InputPlayer == Null) continue;
				
				declare LocalPlayer <=> InputPlayer;
				if (GUIPlayer != Null) LocalPlayer <=> GUIPlayer;
				
				// Events
				foreach (Event in PendingEvents) {
					switch (Event.Type) {
						case CMlEvent::Type::KeyPress: {
							switch (Event.KeyCode) {
								case 29: {
									// Delete
									if (IsSpectatorMode || InputPlayer.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) {
										continue;
									}
									declare netwrite Integer Net_RetireTime for UI;
									Net_RetireTime = ArenaNow;
								}
							}
						}
					}
				}
				
				// WarmUp
				if (Old_RemainingWarmUp != Net_RemainingWarmUp) {
					Old_RemainingWarmUp = Net_RemainingWarmUp;
					if (Net_RemainingWarmUp != "") {
						Frame_WarmUp.Visible = True;
						Label_WarmUp.Value = TextLib::Compose(_("WarmUp: %1"), Net_RemainingWarmUp);
					} else {
						Frame_WarmUp.Visible = False;
					}
				}
				
				// Chrono
				if (Net_StartTime > 0) {
					Frame_Chrono.Visible = True;
					declare netread Net_CurrentTime for LocalPlayer = -1;
					if (Net_CurrentTime > 0 && LastStartTime == Net_StartTime) {
						Label_Chrono.Value = TextLib::TimeToText(Net_CurrentTime, True);
					} else {
						Label_Chrono.Value = TextLib::TimeToText(ArenaNow - Net_StartTime, True);
						if (Net_CurrentTime < 0) {
							LastStartTime = Net_StartTime;
						}
					}
				} else {
					Frame_Chrono.Visible = False;
				}
				
				// SpeedoMeter
				if (Net_StartTime > 0) {
					if (LastPositionTime + 100 > Now) continue;
					Frame_SpeedoMeter.Visible = True;
					if (LocalPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
						if (LocalPlayer.Position != <0., 0., 0.> && LastPosition != <0., 0., 0.>) {
							declare Speed = (3600. * MathLib::Distance(LastPosition, LocalPlayer.Position)) / MathLib::ToReal(Now - LastPositionTime);
							if (LastSpeed > 0) {
								Label_Speed.Value = TextLib::Compose("%1 km/h", TextLib::ToText(Round((Speed + LastSpeed) / 2.)));
							} else {
								Label_Speed.Value = TextLib::Compose("%1 km/h", TextLib::ToText(Round(Speed)));
							}
							LastSpeed = Speed;
						}
						LastPosition = LocalPlayer.Position;
						LastPositionTime = Now;
						continue;
					}
					Label_Speed.Value = TextLib::Compose("%1 km/h", TextLib::ToText(Round(0.)));
				} else {
					Frame_SpeedoMeter.Visible = False;
				}
			}
		}
		--></script>
		<frame id="Frame_WarmUp" posn="{{{C_RankingsListPosition[0]+7.}}} {{{C_RankingsListPosition[1]+7.}}}" hidden="1">
			<label id="Label_WarmUp" posn="1 0" textsize="2" textprefix="$o$fc0" halign="left" valign="center2"/>
			<quad posn="0 0" sizen="{{{WarmUpFlagWidth*16.}}} {{{WarmUpFlagWidth*9.}}}"
				style="BgRaceScore2" substyle="Warmup" halign="right" valign="center2"/>
		</frame>
		<frame id="Frame_Chrono" posn="{{{C_ChronoPosition[0]}}} {{{C_ChronoPosition[1]}}}">
			<label id="Label_Chrono" posn="0 -0.9 1" style="TextRaceChrono" halign="center" valign="center2"/>
			<quad posn="0 0" sizen="40 10" style="BgsPlayerCard" substyle="BgPlayerCard" halign="center" valign="center2"/>
		</frame>
		<frame id="Frame_SpeedoMeter" posn="{{{C_SpeedoMeterPosition[0]}}} {{{C_SpeedoMeterPosition[1]}}}">
			<label id="Label_Speed" posn="15 -0.7" textsize="5" style="TextRaceChrono" halign="right" valign="center2"/>
			<quad sizen="37 9" style="BgsPlayerCard" substyle="BgPlayerCard" halign="center" valign="center2"/>
		</frame>""";
}

// Checks net variables of extras layer
Void UpdateExtrasLayer() {
	// Update chrono values
	declare netwrite Integer Net_StartTime for Teams[0];
	Net_StartTime = This.StartTime;
	
	if (This.StartTime < 0 || This.Now < This.StartTime) return;
	
	// Check for retirements
	foreach (Player in Players) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		declare netread Net_RetireTime for UI = 0;
		declare LastRetireTime for UI = 0;
		if (LastRetireTime < Net_RetireTime && Net_RetireTime > This.StartTime) {
			LastRetireTime = Net_RetireTime;
			UnspawnPlayer(Player);
			UIManager.UIAll.SendNotice(TextLib::Compose(_("$<%1$> retired!"), Player.Name),
				CUIConfig::ENoticeLevel::PlayerInfo, Player.User, CUIConfig::EAvatarVariant::Default,
				CUIConfig::EUISound::Silence, 0);
		}
	}
}

// Create manialink for rankings layer
Text GetRankingsLayerManialink() {
	if (C_RankingsListLength <= 0) return "";
	declare Manialink = """<script><!--
		#Include "TextLib" as TextLib
		
		#Const	C_PointsList	[""";
	foreach (Index => RankPoints in C_PointsList) {
		Manialink ^= ""^RankPoints;
		if (Index < C_PointsList.count -1) {
			Manialink ^= ",";
		}
	}
	Manialink ^= """]
		
		main() {
			declare Frame_Ranking <=> (Page.GetFirstChild("Frame_Ranking") as CMlFrame);
			declare Quad_SelfHighlight <=> (Frame_Ranking.GetFirstChild("Quad_SelfHighlight") as CMlQuad);
			
			declare RankingFrames = [""";
	for (Index, 1, C_RankingsListLength) {
		Manialink ^= """{{{Index}}} => (Frame_Ranking.GetFirstChild("Frame_Ranking{{{Index}}}") as CMlFrame)""";
		if (Index < C_RankingsListLength) {
			Manialink ^= ",";
		}
	}
	Manialink ^= """];
	
			foreach (Rank => Frame in RankingFrames) {
				declare Label_Rank <=> (Frame.GetFirstChild("Label_Rank") as CMlLabel);
				declare Label_Points <=> (Frame.GetFirstChild("Label_Points") as CMlLabel);
				Label_Rank.Value = TextLib::ToText(Rank);
				if (C_PointsList.existskey(Rank - 1)) {
					Label_Points.Value = TextLib::ToText(C_PointsList[Rank - 1]);
				}
			}
			
			declare netread Net_RemainingWarmUp for Teams[0] = "";
			
			declare LastUIUpdate = 0;
			declare LastPlayerTimesCount = 0;
			
			while (True) {
				yield;
				
				if (InputPlayer == Null) continue;
				
				if (LastUIUpdate + 300 > Now) continue;
				LastUIUpdate = Now;
				
				declare Integer[Text] PlayersTimes;
				
				foreach (Player in Players) {
					declare netread Net_CurrentTime for Player = -1;
					if (Net_CurrentTime > 0) {
						PlayersTimes[Player.Name] = Net_CurrentTime;
					}
				}
				if (LastPlayerTimesCount == PlayersTimes.count) continue;
				LastPlayerTimesCount = PlayersTimes.count;
				
				PlayersTimes = PlayersTimes.sort();
				
				Quad_SelfHighlight.Visible = PlayersTimes.existskey(InputPlayer.Name);
				
				declare Rank = 1;
				foreach (Name => Time in PlayersTimes) {
					if (!RankingFrames.existskey(Rank) || RankingFrames[Rank] == Null) continue;
					
					declare Frame			<=> RankingFrames[Rank];
					declare Label_Name		<=> (Frame.GetFirstChild("Label_Name") as CMlLabel);
					declare Label_Time		<=> (Frame.GetFirstChild("Label_Time") as CMlLabel);
					declare Label_Points	<=> (Frame.GetFirstChild("Label_Points") as CMlLabel);
					
					Frame.Visible			= True;
					Label_Name.Value		= Name;
					Label_Time.Value		= TextLib::TimeToText(Time, True);
					Label_Points.Visible	= (Net_RemainingWarmUp == "");
					
					if (Name == InputPlayer.Name) {
						Quad_SelfHighlight.PosnY = (1 - Rank) * 3.5;
					}
					
					Rank += 1;
				}
				for (Index, Rank, {{{C_RankingsListLength}}}) {
					if (!RankingFrames.existskey(Index)) continue;
					RankingFrames[Index].Visible = False;
				}
			}
		}
		--></script>
		<framemodel id="FrameModel_RankingFrame">
			<format textsize="1"/>
			<label id="Label_Rank" posn="0 0" sizen="3 0" textprefix="$o" halign="center" valign="center2"/>
			<label id="Label_Name" posn="3 0" sizen="20 0" halign="left" valign="center2"/>
			<label id="Label_Time" posn="25 0" sizen="10 0" halign="left" valign="center2"/>
			<label id="Label_Points" posn="41 0" sizen="4 0" textprefix="$3f3+" halign="right" valign="center2"/>
		</framemodel>
		<frame id="Frame_Ranking" posn="{{{C_RankingsListPosition[0]}}} {{{C_RankingsListPosition[1]}}} -1">
			<quad id="Quad_SelfHighlight" posn="-2.7 0" sizen="38.8 3.6" style="Icons128x128_1" substyle="ShareBlink"
				hidden="1" halign="left" valign="center2"/>""";
	for (Index, 1, C_RankingsListLength) {
		Manialink ^= """<frameinstance modelid="FrameModel_RankingFrame" id="Frame_Ranking{{{Index}}}" hidden="1"
			posn="0 {{{(1-Index)*3.5}}}"/>""";
	}
	Manialink ^= """
		</frame>""";
	return Manialink;
}
