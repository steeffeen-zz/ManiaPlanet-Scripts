/********************************************
*	SpeedBall Game Mode						*
*	Author:		steeffeen					*
*	Contact:	steeffeen@team-devota.com	*
********************************************/

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const	ScriptName			"SpeedBall.Script.txt"
#Const	Version				"2.2 (2014-03-31)"
#Const	CompatibleMapTypes	"SpeedBallArena,SpeedBallTitleArena"

/*****************************************************
	INCLUDES
*****************************************************/

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Markers.Script.txt" as Markers
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/MiniMap2.Script.txt" as MiniMap
#Include "Libs/Nadeo/TabsServer.Script.txt" as Tabs
#Include "Libs/Nadeo/Top2.Script.txt" as Top
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/Nadeo/ShootMania/WarmUp2.Script.txt" as WarmUp2
#Include "Libs/steeffeen/ShootMania/Bots.Script.txt" as Bots
#Include "Libs/steeffeen/TeamStats.Script.txt" as TeamStats
#Include "Libs/steeffeen/Tools.Script.txt" as Tools

/*****************************************************
	SETTINGS
*****************************************************/

// Rounds
#Setting	S_TimeLimitNormal			180		as _("Duration Normal Phase (seconds)")
#Setting	S_TimeLimitReduction		120		as _("Duration Reduction Phase (seconds)")
#Setting	S_TimeLimitInstant			300		as _("Duration Instant Phase (seconds)")
#Setting	S_RoundsToWin				5		as _("Rounds to win a map")
#Setting	S_RoundGapToWin				2		as _("Rounds gap to win a map")
#Setting	S_RoundsLimit				10		as _("Total rounds limit per map (First team reaching X wins)")
#Setting	S_BestOfXMatch				0		as _("Play best-of-X-maps match")
#Setting	S_UseWarmUp					False	as _("Start a warmup before each map")
// Teams
#Setting	S_UsePlayerClublinks		False	as _("Enable use of player clublinks (needs restart vote)")
#Setting	S_AutoTeamBalance			False	as _("Automatically balance teams before each map")
// Gameplay
#Setting	S_FriendlyFire				False	as _("Friendly fire (Damage team members)")
#Setting	S_Mode						0		as _("Gameplay Mode (0: Normal, 1: Laser, 2: Random Weapon)")
#Setting	S_ThrowableBall				False	as _("Use a throwable Ball")

// Hidden
#Setting	S_DefaultCaptureTime		1.6		as "<hidden>"		// Default (not-reduced) capture time
#Setting	S_WarmUpDuration			60		as "<hidden>"		// WarmUp duration
#Setting	S_BotPower					10.		as "<hidden>"		// Power of the bots
#Setting	S_NbBotsBlue				0		as "<hidden>"		// Number of bots of team blue
#Setting	S_NbBotsRed					0		as "<hidden>"		// Number of bots of team red
#Setting	S_ReduceLaserDamage			False	as "<hidden>"		// Reduce laser damage?

/*****************************************************
	COMMANDS
*****************************************************/

#Command	Cmd_MapPointsClan1		(Integer)	as _("Set current Map Points of Team 1")
#Command	Cmd_MapPointsClan2		(Integer)	as _("Set current Map Points of Team 2")
#Command	Cmd_MatchPointsClan1	(Integer)	as _("Set current Match Points of Team 1")
#Command	Cmd_MatchPointsClan2	(Integer)	as _("Set current Match Points of Team 2")

/*****************************************************
	CONSTANTS
*****************************************************/

// Gameplay
#Const	C_ExtendedAntiBlockTime			5500		// Duration during which players don't block each other after roundbegin
#Const	C_BallCarrierArmorReplenishGain	200			// Value for the armor regeneration of the ball carrier
#Const	C_DroppedBallResetTime			4500		// Time until a dropped ball will reset
#Const	C_PlayerHighlightValue			0.6			// How much the players get highlighted (ball carrier -> 1.0)
#Const	C_BotsCanHaveBall				True		// Disable to disallow bots to have the ball
#Const	C_DecrDamageOnBall				True		// Ball carrier can only be hit for 1 damage (even from laser)
#Const	C_ThrowSpeed					45.			// Player throw speed
// UI
#Const 	C_ImgBaseDir					"file://Media/Manialinks/Shootmania/Common/"
#Const	C_DefaultNeutralEmblemUrl		"http://team-devota.com/steeffeen/images/emblem_speedball.dds"		// Default neutral emblem URL
#Const	C_MissMessageMaxDist			0.9			// Maximum distance for near miss messages
#Const	C_HitMessageMinDist				40.			// Minimum distance for hit missage
#Const	C_NbTeamHitMessage				8			// Times the team hit warning appears (0: deactivated, -1: endless)
// ScoresTable
#Const	C_ST_ColId_Damage				"SB.Damage"
#Const	C_ST_ColId_Passes				"SB.Passes"

#Const	Description			_("$<$oObjective:$> Two teams fight for control of a $<$0f0Ball$> in order to capture the opponents goal post.")

// Warm up
#Const	C_Clan1				"Clan1"
#Const	C_Clan2				"Clan2"

// Top ranking names
#Const	T_Damage			"Damage"
#Const	T_Captures			"Captures"
#Const	T_Passes			"Passes"
#Const	T_BallHitters		"BallHitters"
#Const	T_BackStabber		"BackStabber"
#Const	T_CaptureTotal		"CaptureTotal"

// Stats names
#Const	T_BallPoss			"BallPossession"
#Const	T_CaptureTries		"CaptureTries"
#Const	T_EnemyKills		"EnemyKills"
#Const	T_TeamKills			"TeamKills"

/*****************************************************
	GLOBALES
*****************************************************/

declare	Integer[Integer]		G_ClanMapScores;			// Won maps of each clan
declare	Integer					G_Phase;					// Current gameplay phase (0: normal, 1: reduction, 2: instant)
declare	Ident					G_BallItemId;				// Id of ball item
declare Ident[]					G_BallObjectsIds;			// Ids of all ball objects
declare	Integer					G_LastUIUpdate;				// Time when the last UI refresh was performed
declare	Ident					G_BallLandmarkId;			// Id of the ball landmark
declare	Ident[Integer][Integer]	G_ClanSpawnLandmarkIds;		// Spawn Landmark Ids of each clan
declare	Integer[Integer]		G_LastSpawnIndex;			// Last spawn index of each clan
declare	Ident[Integer]			G_ClanGaugeLandmarkIds;		// Gauge Landmark Ids of each clan
declare Real[Integer]			G_MaxCapturePercentage;		// Maximum capture percentage reached by each team during the current round

/*****************************************************
	LABELS
*****************************************************/

***LogVersion***
***
MB_LogVersion(ScriptName, Version);
MB_LogVersion(Interface::GetScriptName(), Interface::GetScriptVersion());
MB_LogVersion(Markers::GetScriptName(), Markers::GetScriptVersion());
MB_LogVersion(Message::GetScriptName(), Message::GetScriptVersion());
MB_LogVersion(MiniMap::GetScriptName(), MiniMap::GetScriptVersion());
MB_LogVersion(Score::GetScriptName(), Score::GetScriptVersion());
MB_LogVersion(SM::GetScriptName(), SM::GetScriptVersion());
MB_LogVersion(SpawnScreen::GetScriptName(), SpawnScreen::GetScriptVersion());
MB_LogVersion(Tabs::GetScriptName(), Tabs::GetScriptVersion());
MB_LogVersion(Top::GetScriptName(), Top::GetScriptVersion());
MB_LogVersion(Victory::GetScriptName(), Victory::GetScriptVersion());
MB_LogVersion(WarmUp2::GetScriptName(), WarmUp2::GetScriptVersion());
***

***ModeStatusMessage***
***
if (Players.count > 0) {
	declare Message = TextLib::Compose("%1\n$<$o%2:$> %3", Description, _("Score"),
		"$<"^Teams[0].ColorizedName^"$> $<"^Teams[0].ColorText^ClanScores[0]^"$> : $<"
			^Teams[1].ColorText^ClanScores[1]^"$> $<"^Teams[1].ColorizedName^"$>");
	ModeStatusMessage = Message;
} else {
	ModeStatusMessage = Description;
}
***

***Rules***
***
SpawnScreen::ResetRulesSection();
declare OpenBallText = "$<$6f1";
declare OpenSettingText = "$<$f80";
declare OpenNumText = "$<$o";
declare CloseText = "$>";
declare BallText = OpenBallText^"Ball"^CloseText;
declare ModeRules = "- Two Teams fight for Control of the "^BallText^" in order to capture the Opponents Goal post.\n- Grab the "^BallText^" and get it to the Enemy's Pole to score (which takes "^OpenSettingText^S_DefaultCaptureTime^CloseText^" Seconds).\n- Once You have the "^BallText^" it slowly regenerates Your Armor, hit another Player to $<$3afpass$> it.\n- If the "^BallText^" Carrier dies, the "^BallText^" will drop at his Position. It can be picked up by any Player on any Team for "^OpenSettingText^(C_DroppedBallResetTime / 1000.)^CloseText^" Seconds before it resets.";
ModeRules ^= "\n\n- "^OpenNumText^"1. Normal Phase:"^CloseText^" Lasts "^OpenSettingText^(S_TimeLimitNormal / 60.)^CloseText^" Minutes. Normal Capture Time.\n- "^OpenNumText^"2. Reduction Phase:"^CloseText^" Lasts "^OpenSettingText^(S_TimeLimitReduction / 60.)^CloseText^" minutes. The Capture Time constantly decreases.\n- "^OpenNumText^"3. Instant Phase:"^CloseText^" The last "^OpenSettingText^(S_TimeLimitInstant / 60.)^CloseText^" Minutes are running! Captures are instant!\n- If neither Team manages to score the One that has reached the highest Capture Percentage wins.";

SpawnScreen::AddSubsection(_("Rules"), ModeRules, 0.);
if (S_FriendlyFire) {
	SpawnScreen::AddSubsection(TextLib::Compose(_("%1Friendly%2 Fire activated!"), "$<$f80", "$>"), _("Pay Attention to not damage your Team Mates!"),
		90.);
}
switch (S_Mode) {
	case 1: {
		SpawnScreen::AddSubsection(TextLib::Compose(_("%1Laser Mode%2 activated!"), "$<$f80", "$>"), _("Players spawn with Lasers!"), 110.);
	}
	case 2: {
		SpawnScreen::AddSubsection(TextLib::Compose(_("%1Random Mode%2 activated!"), "$<$f80", "$>"), _("Players spawn with random Weapons!"), 110.);
	}
}
SpawnScreen::CreatePrettyRules("SpeedBall");
***

***StartServer***
***
// Load objects
ItemList_Begin();
G_BallItemId = ItemList_Add("SpeedBall\\Ball3.Item.gbx");
if (G_BallItemId == NullId) {
	// Loading failed somehow, lets try again
	G_BallItemId = ItemList_Add("SpeedBall\\Ball3.Item.gbx");
}
ItemList_End();

// Teams
UseClans = True;
Bots::Load();
Bots::SetPower(S_BotPower);

// Clublink & Emblem
MB_UsePlayerClublinks = S_UsePlayerClublinks;
if (MB_NeutralEmblemUrl == "") MB_NeutralEmblemUrl = C_DefaultNeutralEmblemUrl;

// Init variables
MB_UseSectionRound = True;
StartTime = -1;
EndTime = -1;
UIManager.UIAll.CountdownEndTime = -1;
G_LastUIUpdate = 0;
G_MaxCapturePercentage = [1 => -1., 2 => -1.];

// UI
SM::SetupDefaultVisibility();
UIManager.UIAll.UISequence_CanSkipIntroMT = True;
SpawnScreen::SetModeName("SpeedBall");
SpawnScreen::CreateMapInfo();
SpawnScreen::CreateScores("Score.Points");
Interface::CreateRank();
// Hide map warnings to suppress the "Pole captured by X" message
UIManager.UIAll.NoticesFilter_HideMapWarning = True;
Markers::Load();

// Warm up
WarmUp2::Load();
WarmUp2::DisplayClanSelection(True);
WarmUp2::CreateGroup("Clan1", 5);
WarmUp2::CreateGroup("Clan2", 5);

// Layers
declare LayerTeams <=> UIManager.UILayerCreate();
Interface::SetLayerTeams(LayerTeams);
UIManager.UIAll.UILayers.add(LayerTeams);

declare LayerMarkers <=> UIManager.UILayerCreate();
LayerMarkers.Type = CUILayer::EUILayerType::Markers;
LayerMarkers.ManialinkPage = CreateMarkersLayer();
UIManager.UIAll.UILayers.add(LayerMarkers);

declare LayerExtra <=> UIManager.UILayerCreate();
LayerExtra.ManialinkPage = CreateLayerExtra();
UIManager.UIAll.UILayers.add(LayerExtra);

// Tabs
Tabs::Load();
declare TabsLayer <=> Tabs::CreateTabPaneLayer(["ScoresTab" => "Rankings", "TopTab" => "Buddies", "TeamStatsTab" => "Statistics"], 14, -2, False);
TabsLayer.Type = CUILayer::EUILayerType::AltMenu;
UIManager.UIAll.UILayers.add(TabsLayer);

// ScoresTable
ST2::SetStyle("LibST_SMBaseTeams");
ST2::SetStyle("LibST_SMBasePoints");
ST2::SetStyle("LibST_SMWithLegends");
ST2::SetFormat(2, 6);
ST2::SetTeamsScoresVisibility(True);
ST2::CreateCol(C_ST_ColId_Damage, _("|Number of passes done|Passes"), "-", 2.8, 80.);
ST2::CreateCol(C_ST_ColId_Passes, _("|Amount of damage inflicted|Dmg"), "-", 2.8, 90.);
ST2::SetColLegend("LibST_SMRoundPoints", _("|Amount of points in the current round of the match|Round"));
ST2::SetColLegend("LibST_SMPoints", _("|Total amount of points in the match|Total"));
ST2::Build("SM");

{
	// Tops
	Top::Load();
	Top::SetLayerType(CUILayer::EUILayerType::AltMenu);
	declare TopWidth = 72.;
	Top::SetTopWidth(TopWidth);
	Top::SetColor("Background", "0002");
	Top::SetCommonBackgroundImage(C_ImgBaseDir^"topsBg.dds", <0., 96.5>, <237., 177.5>);
	declare Tops = [	T_Damage		=> _("Top Damage"),
						T_BallHitters	=> _("Top BallHitters"),
						T_Passes		=> _("Top Passes"),
						T_Captures		=> _("Top Captures"),
						T_CaptureTotal	=> _("Top Capture% Sum"),
						T_BackStabber	=> _("Flop BackStabber")];
	declare Count = 1;
	declare Line = 0;
	foreach (Key => Name in Tops) {
		Top::Create(Key, Name, 7 - Line, <-146.6 + Count * (TopWidth + 1.1), 41. - Line * 48.2>);
		Count += 1;
		if (Count == 4) {
			Count = 1;
			Line += 1;
		}
	}
	
	// Team Stats
	TeamStats::Load("TeamStatsTab");
	TeamStats::SetBackgroundImage(C_ImgBaseDir^"topsBg.dds", <237., 177.5>, <0., 7.8>);
	declare Stats =	[	T_BallPoss		=> _("Ball Possession"),
						T_Damage		=> _("Damage"),
						T_Passes		=> _("Passes"),
						T_CaptureTries	=> _("Capturing Tries"),
						T_EnemyKills	=> _("Enemy Eliminations"),
						T_TeamKills		=> _("Friend Eliminations")];
	Count = 0;
	foreach (Key => Name in Stats) {
		TeamStats::CreateStat(Key, Name, "-", 14 - 10. * Count);
		Count += 1;
	}
	TeamStats::BuildManialink();
}

// MiniMap
MiniMap::Load();
MiniMap::WorldPositionFollow(True);
MiniMap::MapYawFollow(True);
MiniMap::Zoom(3.5);
MiniMap::MapPosition(<0.5, 0.5>);
***

***StartMatch***
***
G_ClanMapScores = [1 => 0, 2 => 0];
if (S_BestOfXMatch > 0) {
	// Run match
	UIManager.UIAll.SendNotice(_("New Match!"),
		CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default,
		CUIConfig::EUISound::StartMatch, 0);
	UpdateClanScoresSummary(True);
	MB_PlayersPresentationSequence(2500);
	MB_Sleep(500);
}
***

***StartMap***
***
// Create objects
ObjectDestroyAll();
G_BallObjectsIds.clear();
for (Index, 1, 1) {
	declare BallObject = ObjectCreate(G_BallItemId);
	G_BallObjectsIds.add(BallObject.Id);
	BallObject.Throwable = S_ThrowableBall;
	Bots::SetTargetOjectId(BallObject.Id);
}

// UI
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	
// Layers
Interface::AttachRank();
LayerTeams.IsVisible = True;

// Auto team balance
if (S_AutoTeamBalance) {
	Mode::AutoTeamBalance();
	SM::UnspawnAllPlayers();
}

// Prepare match
Score::MatchBegin();
Victory::MatchBegin();
Top::ResetAll();
ResetMatchTops();
ResetStatistics();

ClanScores[1] = 0;
ClanScores[2] = 0;

// Prepare map
G_ClanSpawnLandmarkIds[1] = Ident[Integer];
G_ClanSpawnLandmarkIds[2] = Ident[Integer];
G_ClanGaugeLandmarkIds.clear();
G_BallLandmarkId = NullId;
foreach (Base in MapBases) {
	Base.IsActive = True;
	Base.Clan = 0;
}
foreach (SpawnLandmark in MapLandmarks_PlayerSpawn) {
	if (SpawnLandmark.Tag != "Spawn") continue;
	G_ClanSpawnLandmarkIds[SpawnLandmark.Order][G_ClanSpawnLandmarkIds[SpawnLandmark.Order].count] = SpawnLandmark.Id;
}
foreach (Index => GaugeLandmark in MapLandmarks_Gauge) {
	if (GaugeLandmark.Tag != "Goal") continue;
	switch (GaugeLandmark.Order) {
		case 3: {
			// Ball spawn
			G_BallLandmarkId = GaugeLandmark.Id;
			GaugeLandmark.Gauge.ValueReal = 1.;
			declare netwrite Integer Net_BallLandmarkIndex for Teams[0];
			Net_BallLandmarkIndex = Index;
			Bots::SetAnchorPoint(GaugeLandmark.Position);
		}
		default: {
			G_ClanGaugeLandmarkIds[3 - GaugeLandmark.Order] = GaugeLandmark.Id;
			GaugeLandmark.Gauge.Max = MathLib::NearestInteger(S_DefaultCaptureTime * 1000.);
		}
	}
}

---Rules---

// Start match
UpdateNetVariables();
UpdateClanScoresSummary(True);
// WarmUp
if (S_UseWarmUp) {
	DoWarmup();
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
}
SM::UnspawnAllPlayers();
// Clublinks
if (S_UsePlayerClublinks) {
	Clublink::DefineTeamAuto();
}
if (S_BestOfXMatch <= 0) {
	UIManager.UIAll.SendNotice("",
		CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default,
		CUIConfig::EUISound::StartMatch, 0);
}
***

***StartRound***
***
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.SpectatorForcedTarget = NullId;
Score::RoundBegin();
ResetRoundTops();
AssignSpawnsGaugesClans();
UIManager.UIAll.SendNotice("",
	CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default,
	CUIConfig::EUISound::StartRound, 0);
Victory::RoundBegin();
LayerMarkers.IsVisible = True;
LayerExtra.IsVisible = True;

// Initialize values
foreach (BallObjectId in G_BallObjectsIds) {
	if (!Objects.existskey(BallObjectId)) continue;
	declare BallObject <=> Objects[BallObjectId];
	BallObject.SetPositionAndVel(MapLandmarks_Gauge[G_BallLandmarkId].Position, <0., 1., 0.>);
	declare Integer DropTime for BallObject;
	DropTime = -1;
	declare Boolean AtHome for BallObject;
	AtHome = True;
}
G_Phase = 0;
UpdateBaseClans();
G_MaxCapturePercentage = [1 => 0., 2 => 0.];

// Update markers
UpdateHud3dMarkers(False);

// Set round times
StartTime = Now + 4000;
EndTime = StartTime + (S_TimeLimitNormal + S_TimeLimitReduction + S_TimeLimitInstant) * 1000;
UIManager.UIAll.CountdownEndTime = StartTime + S_TimeLimitNormal * 1000;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
UsePvPCollisions = False;

UpdateClanScoresSummary(True);
UpdateNetVariables();
---ModeStatusMessage---
Bots::SetNbBots(S_NbBotsBlue, S_NbBotsRed);
UseBeaconsWithRecipients = True;
***

***OnNewPlayer***
***
//bye
//ScoresTable::RestoreCustomScores(Player);
Markers::Minimap_Add(Player.Login, Player, True, "Never", "WhenInFrame","file://Media/Manialinks/Common/Pointer.dds", Null);
declare UI <=> UIManager.GetUI(Player);
if (UI == Null) continue;
Tabs::UseTabs(UI, "ScoresTab");
***

***OnNewSpectator***
***
//bye
//ScoresTable::RestoreCustomScores(Spectator);
RemoveMarker(Spectator.User);
declare UI <=> UIManager.GetUI(Spectator);
if (UI == Null) continue;
Tabs::UseTabs(UI, "ScoresTab");
***

***Yield***
***
// Library updates #1
Message::Loop();
Tabs::XmlRpcLoop();
Bots::Loop();
***

***PlayLoop***
***
// Check anti block
if (!UsePvPCollisions && StartTime + C_ExtendedAntiBlockTime < Now) {
	UsePvPCollisions = True;
}

// Check for changed settings
CheckSettings();

// Perform actions for each player
foreach (Player in Players) {
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			// Player not spawned -> Spawn him!
			MySpawnPlayer(Player);
		}
		case CSmPlayer::ESpawnStatus::Spawned: {
			declare HasBall = (HasBalls(Player) > 0);
			// Check for respawn requests
			if (Player.CurrentClan != Player.RequestedClan || Player.RequestsSpectate) {
				if (HasBall) {
					DropBalls(Player);
				}
				UnspawnPlayer(Player);
			} else {
				if (HasBall) {
					// Ball carrier!
					Player.EnergyLevel = 1.;
					Player.ArmorReplenishGain = C_BallCarrierArmorReplenishGain;
					Player.UseAlternateWeaponVisual = True;
				} else {
					// Usual player (without ball)
					Player.EnergyLevel = C_PlayerHighlightValue;
					Player.ArmorReplenishGain = 0;
					// Reduce armor to even values if the player has partly regenerated armor
					if (Player.Armor > 100 && Player.Armor < 200) {
						Player.Armor = 100;
					}
					// Disable alternate ball weapon visual
					Player.UseAlternateWeaponVisual = False;
				}
			}
		}
	}
}

// Handle pending events
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnArmorEmpty: {
			if (Event.Victim == Null) {
				Discard(Event);
			} else {
				DropBalls(Event.Victim);
				if (Event.Shooter != Null) {
					if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
						UpdateStatTeamKills(Event.Shooter.CurrentClan - 1, 1);
					} else {
						UpdateStatEnemyKills(Event.Shooter.CurrentClan - 1, 1);
					}
				}
				if (Event.Victim != Null && !Event.Victim.IsFakePlayer && (Event.Shooter == Null || !Event.Shooter.IsFakePlayer)) {
					XmlRpc::OnArmorEmpty(Event);
				}
				PassOn(Event);
			}
		}
		case CSmModeEvent::EType::OnHit: {
			if (Event.Shooter == Null || Event.Victim == Null || Event.Shooter == Event.Victim) {
				Discard(Event);
			} else {
				if (!S_ThrowableBall && HasBalls(Event.Shooter) > 0) {
					// Ball carrier hit someone -> Pass the ball
					PassBall(Event.Shooter, Event.Victim, GetBall(Event.Shooter));
					SendHitMessage(Event, True);
					Discard(Event);
				} else {
					declare TeamHit = (Event.Shooter.CurrentClan == Event.Victim.CurrentClan);
					if (TeamHit && !S_FriendlyFire) {
						// Discard team hit
						Discard(Event);
					} else {
						// Perform hit
						declare VictimHasBall = (HasBalls(Event.Victim) > 0);
						if (S_ReduceLaserDamage || VictimHasBall) {
							Event.Damage = 100;
						}
						// Calculate points
						declare Points = 1;
						if (TeamHit) Points *= -1;
						if (VictimHasBall) {
							Points *= 2;
						}
						// Grant points & update stats
						Event.ShooterPoints = Points;
						AddPoints(Event.Shooter, Points);
						if (TeamHit) {
							UpdateBackStabs(Event.Shooter, -Points);
							// Show team hit warning
							if (C_NbTeamHitMessage != 0) {
								declare NbTeamHitMessage for Event.Shooter = 0;
								if (C_NbTeamHitMessage < 0 || NbTeamHitMessage < C_NbTeamHitMessage) {
									Message::SendStatusMessage(Event.Shooter, TextLib::Compose("$f80%1", _("Attention! You shot a Team Member!")),
										2500, 0);
									NbTeamHitMessage += 1;
								}
							}
						} else {
							if (VictimHasBall) UpdateBallHits(Event.Shooter, 1);
							UpdateDamage(Event.Shooter, Event.Damage / 100);
							UpdateStatDamage(Event.Shooter.CurrentClan - 1, Event.Damage / 100);
							if (!Event.Shooter.IsFakePlayer) {
								XmlRpc::OnHit(Event);
							}
						}
						// Kill victim if he hasn't full armor
						if (Event.Victim.Armor < 200) {
							Event.Damage = Event.Victim.Armor;
						}
						SendHitMessage(Event, False);
						PassOn(Event);
					}
				}
			}
		}
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
			if (Event.Player == Null) {
				Discard(Event);
			} else {
				DropBalls(Event.Player);
				if (!Event.Player.IsFakePlayer) {
					XmlRpc::OnPlayerRequestRespawn(Event);
				}
				PassOn(Event);
			}
		}
		case CSmModeEvent::EType::OnCapture: {
			if (Event.Landmark == Null || Event.Landmark.Gauge == Null || !G_ClanGaugeLandmarkIds.exists(Event.Landmark.Id)) {
				Discard(Event);
				continue;
			}
			declare CSmObject BallObject <=> Null;
			foreach (BallObjectId in G_BallObjectsIds) {
				if (!Objects.existskey(BallObjectId)) continue;
				declare CurrentBallObject <=> Objects[BallObjectId];
				if (CurrentBallObject.Player == Null || CurrentBallObject.Player.CapturedLandmark != Event.Landmark) continue;
				if (CurrentBallObject.Player.CurrentClan != Event.Landmark.Gauge.Clan) continue;
				BallObject = CurrentBallObject;
			}
			if (BallObject == Null) {
				Discard(Event);
			} else {
				// Captured! - Announce winner etc.
				Victory::SetRoundWinnerIfNoWinner(Event.Landmark.Gauge.Clan);
				UIManager.UIAll.SpectatorForcedTarget = Event.Landmark.Id;
				UIManager.UIAll.BigMessage = "";
				// Reward ball carrier
				AddPoints(BallObject.Player, 5);
				UpdateCaptures(BallObject.Player, 1);
				if (!BallObject.Player.IsFakePlayer) {
					XmlRpc.SendCallback("poleCapture", BallObject.Player.Login);
				}
				UIManager.UIAll.SendNotice(TextLib::Compose(_("%1 scores for %2!"),
					GetColorizedPlayerName(BallObject.Player), "$<"^Teams[BallObject.Player.CurrentClan-1].ColorizedName^"$>"),
					CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default,
					CUIConfig::EUISound::Capture, 0);
				PassOn(Event);
			}
		}
		case CSmModeEvent::EType::OnShoot: {
			// Near miss
			if (Event.Shooter == Null) {
				Discard(Event);
			} else {
				if (!Event.Shooter.IsFakePlayer) {
					XmlRpc::OnShoot(Event);
				}
				PassOn(Event);
			}
		}
		case CSmModeEvent::EType::OnNearMiss: {
			// Near miss
			if (Event.Shooter == Null || Event.Shooter.IsFakePlayer || C_MissMessageMaxDist <= 0. || Event.MissDist > C_MissMessageMaxDist) {
				Discard(Event);
			} else {
				declare Message = GetNearMissMessage(Event);
				if (Message != "") {
					Message::SendStatusMessage(Event.Shooter, Message, 2500, 0);
					XmlRpc::OnNearMiss(Event);
					PassOn(Event);
				} else {
					Discard(Event);
				}
			}
		}
		case CSmModeEvent::EType::OnPlayerTouchesObject: {
			// Player touches ball object
			if (Event.Object == Null || !G_BallObjectsIds.exists(Event.Object.Id) || !PickUpBall(Event.Player, Event.Object)) {
				Discard(Event);
			} else {
				PassOn(Event);
			}
		}
		case CSmModeEvent::EType::OnPlayerThrowsObject: {
			// Player throws ball object
			if (Event.Object == Null) {
				Discard(Event);
			} else {
				declare Integer DropTime for Event.Object;
				DropTime = Now + 3000;
				PassOn(Event);
				
				UpdateHud3dMarkers(True);
			}
		}
		case CSmModeEvent::EType::OnCommand: {
			switch (Event.CommandName) {
				case "Cmd_MapPointsClan1": {
					ClanScores[1] = Event.CommandValueInteger;
					PassOn(Event);
				}
				case "Cmd_MapPointsClan2": {
					ClanScores[2] = Event.CommandValueInteger;
					PassOn(Event);
				}
				case "Cmd_MatchPointsClan1": {
					G_ClanMapScores[1] = Event.CommandValueInteger;
					PassOn(Event);
				}
				case "Cmd_MatchPointsClan2": {
					G_ClanMapScores[2] = Event.CommandValueInteger;
					PassOn(Event);
				}
				default: {
					Discard(Event);
				}
			}
		}
		case CSmModeEvent::EType::OnPlayerRemoved: {
			// Player left the game
			RemoveMarker(Event.User);
			foreach (BallObjectId in G_BallObjectsIds) {
				if (!Objects.existskey(BallObjectId)) continue;
				declare BallObject <=> Objects[BallObjectId];
				declare PlayerId for BallObject = NullId;
				if (Event.PlayerId == PlayerId) {
					DropBall(BallObject, Event.PlayerLastPosition);
				}
			}
			PassOn(Event);
		}
		default: {
			PassOn(Event);
		}
	}
}


// Library updates #2
Top::Loop();

// Check for captures
foreach (GaugeLandmark in MapLandmarks_Gauge) {
	// Team Goals
	if (!G_ClanGaugeLandmarkIds.exists(GaugeLandmark.Id)) continue;
	if (Victory::NoRoundWinner()) {
		GaugeLandmark.Gauge.Speed = MathLib::NearestInteger(S_DefaultCaptureTime * -1000.);
	}
	declare BallAtLandmark = False;
	declare CaptureTime = GetCaptureTime();
	foreach (BallObjectId in G_BallObjectsIds) {
		if (!Objects.existskey(BallObjectId)) continue;
		declare BallObject <=> Objects[BallObjectId];
		if (BallObject.Player == Null) continue;
		if (GaugeLandmark.Sector.PlayersIds.exists(BallObject.Player.Id) && GaugeLandmark.Id == G_ClanGaugeLandmarkIds[BallObject.Player.CurrentClan]) {
			GaugeLandmark.Gauge.Speed = 1;
			if (GaugeLandmark.Gauge.ValueReal < 1.) {
				UpdateCaptureTotal(BallObject.Player, Period);
				if (GaugeLandmark.Gauge.ValueReal == 0.) {
					UpdateStatCaptureTries(GaugeLandmark.Gauge.Clan - 1, 1);
				}
				if (CaptureTime <= 1) {
					GaugeLandmark.Gauge.ValueReal = 1.;
				}
			}
			if (G_MaxCapturePercentage.existskey(GaugeLandmark.Gauge.Clan)
				&& G_MaxCapturePercentage[GaugeLandmark.Gauge.Clan] < GaugeLandmark.Gauge.ValueReal) {
				G_MaxCapturePercentage[GaugeLandmark.Gauge.Clan] = GaugeLandmark.Gauge.ValueReal;
				UpdateClanScoresSummary(False);
			}
			BallAtLandmark = True;
		}
	}
	if (!BallAtLandmark) {
		// Prevent weird bug causing the gauge stay fully captured without an OnCapture event
		if (!GaugeLandmark.Gauge.Captured && GaugeLandmark.Gauge.ValueReal >= 1. && Now < EndTime) {
			GaugeLandmark.Gauge.ValueReal = 0.99;
		}
	}
	if (GaugeLandmark.Gauge.ValueReal <= 0.) {
		GaugeLandmark.Gauge.Max = CaptureTime;
	}
}

// Balls stuff
foreach (BallObjectId in G_BallObjectsIds) {
	if (!Objects.existskey(BallObjectId)) continue;
	declare BallObject <=> Objects[BallObjectId];
	switch (BallObject.Status) {
		case CSmObject::EStatus::Unspawned: {
			// Reset ball
			ResetBall(BallObject);
		}
		case CSmObject::EStatus::InWorld: {
			if (GetRmDrpdBallTime(BallObject) < 0) {
				// Dropped ball reset
				ResetBall(BallObject);
			}
		}
		case CSmObject::EStatus::OnPlayer: {
			if (BallObject.Player == Null) continue;
			if (BallObject.Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
				if (Period > 0) {
					// Ball held by player
					UpdateStatBallPossession(BallObject.Player.CurrentClan - 1, Period);
				}
			} else {
				if (BallObject.Player.Position != <0., 0., 0.>) {
					// Drop ball
					DropBall(BallObject, BallObject.Player.Position);
				} else {
					// Reset ball because of unknown position
					ResetBall(BallObject);
				}
			}
		}
	}
}

// UI updates
if (G_LastUIUpdate + 240 < Now) {
	G_LastUIUpdate = Now;
	
	// Ball carrier speccing
	UIManager.UIAll.SpectatorAutoTarget = NullId;
	foreach (BallObjectId in G_BallObjectsIds) {
		if (!Objects.existskey(BallObjectId)) continue;
		declare BallObject <=> Objects[BallObjectId];
		if (BallObject.Player == Null) continue;
		UIManager.UIAll.SpectatorAutoTarget = BallObject.Player.Id;
	}
	
	// Clan scores at the top
	UpdateClanScoresSummary(False);
	
	// Update net values
	UpdateNetVariables();
}

// Check round end conditions
if (Now >= EndTime) {
	// Time is up - Perform round draw
	Victory::SetRoundDrawIfNoWinner();
	MB_StopRound = True;
} else {
	if (!MB_StopRound && !Victory::NoRoundWinner()) {
		// Round winner found
		MB_StopRound = True;
	} else {
		if (Now >= UIManager.UIAll.CountdownEndTime && UIManager.UIAll.CountdownEndTime > 0) {
			// New gameplay phase!
			G_Phase += 1;
			switch (G_Phase) {
				case 1: {
					// Reduction phase began
					UIManager.UIAll.SendNotice(TextLib::Compose("$fc3%1", _("Reduction Phase!")),
						CUIConfig::ENoticeLevel::MatchWarning, Null, CUIConfig::EAvatarVariant::Default,
						CUIConfig::EUISound::PhaseChange, 0);
					UIManager.UIAll.CountdownEndTime = Now + S_TimeLimitReduction * 1000;
				}
				case 2: {
					// Instant phase began
					UIManager.UIAll.SendNotice(TextLib::Compose("$f60%1", _("Instant Phase!")),
						CUIConfig::ENoticeLevel::MatchWarning, Null, CUIConfig::EAvatarVariant::Default,
						CUIConfig::EUISound::PhaseChange, 1);
					UIManager.UIAll.CountdownEndTime = -1;
				}
			}
		}
	}
}
***

***EndRound***
***
StartTime = -1;
EndTime = -1;
UIManager.UIAll.CountdownEndTime = -1;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UpdateNetVariables();
LayerMarkers.IsVisible = False;
MB_Sleep(2500);

foreach (BallObjectId in G_BallObjectsIds) {
	if (!Objects.existskey(BallObjectId)) continue;
	declare BallObject <=> Objects[BallObjectId];
	BallObject.SetUnspawned();
}

LayerExtra.IsVisible = False;
UnspawnObjects(G_BallObjectsIds);
SM::UnspawnAllPlayers();

MB_Sleep(1000);

// Evaluate round
declare Message = _("Round Draw");
if (!Victory::IsRoundDraw()) {
	foreach (Index => Team in Teams) {
		if (Victory::IsRoundWinner(Index + 1)) {
			// Team 'Index' wins the round by capturing
			ClanScores[Index + 1] += 1;
			Message = TextLib::Compose(_("%1 wins the Round!"), "$<"^Team.ColorizedName^"$>");
			UpdateClanScoresSummary(False);
			break;
		}
	}
} else {
	foreach (Index => Team in Teams) {
		if (G_MaxCapturePercentage.existskey(Index+1) && G_MaxCapturePercentage[Index+1] > G_MaxCapturePercentage[2-Index]) {
			// Team 'Index' wins the round with the higher capture percentage
			ClanScores[Index+1] += 1;
			Message = TextLib::Compose(_("%1 wins the Round with %2%%!"), "$<"^Team.ColorizedName^"$>",
				TextLib::ToText(MathLib::NearestInteger(G_MaxCapturePercentage[Index+1] * 1000.) / 10.));
			UpdateClanScoresSummary(False);
			break;
		}
	}
}
	
Message::CleanBigMessages();
UIManager.UIAll.SendNotice(Message,
	CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default,
	CUIConfig::EUISound::EndRound, 0);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

// Check match end conditions
Victory::SetMatchWinnerFromScore(S_RoundsToWin, S_RoundGapToWin, S_RoundsLimit);
if (!Victory::NoMatchWinner()) {
	// Match winner found
	MB_StopMap = True;
}

// Wait to let the players take a breath
MB_Sleep(3500);
Victory::RoundEnd();
***

***EndMap***
***
Score::MatchEnd();
Victory::MatchEnd();

// Destroy objects
ObjectDestroyAll();

// UI
Markers::Clear();
Message::CleanAllMessages();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;

// Hide stuff
Interface::DetachRank();
LayerTeams.IsVisible = False;

// Announce victorious clan
declare Message = _("Map Draw");
if (!Victory::IsMatchDraw()) {
	foreach (Index => Team in Teams) {
		if (Victory::IsMatchWinner(Index + 1)) {
			// Team 'Index' wins the match
			Message = TextLib::Compose(_("%1 wins the Map!"), "$<"^Team.ColorizedName^"$>");
			G_ClanMapScores[Index + 1] += 1;
			break;
		}
	}
}

UpdateClanScoresSummary(True);
UIManager.UIAll.SendNotice(Message,
	CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default, 
	CUIConfig::EUISound::EndMatch, 0);

MB_Sleep(3500);
Message::CleanAllMessages();

if (S_BestOfXMatch > 0 && G_ClanMapScores[1] + G_ClanMapScores[2] >= S_BestOfXMatch) {
	// Match over
	MB_StopMatch = True;
	declare ClanWon = [1 => False, 2 => False];
	foreach (Index => Team in Teams) {
		if (G_ClanMapScores[Index + 1] > S_BestOfXMatch * 0.5) {
			ClanWon[Index + 1] = True;
		}
	}
	Message = _("Match Draw");
	foreach (Clan => Won in ClanWon) {
		if (Won && !ClanWon[3 - Clan]) {
			Message = TextLib::Compose(_("%1 wins the Match!"), "$<"^Teams[Clan - 1].ColorizedName^"$>");
		}
	}

	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	UIManager.UIAll.SendNotice(Message,
		CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::EndMatch, 0);
	MB_Sleep(3500);
}
***

***EndServer***
***
// UI Cleanup
Top::Unload();
TeamStats::Unload();
Interface::DestroyRank();
SpawnScreen::DestroyRules();
Markers::Unload();
WarmUp2::Unload();
MiniMap::Unload();
Bots::Unload();
UIManager.UILayerDestroyAll();
***

/*****************************************************
	FUNCTIONS
*****************************************************/

// Check if the given player is carrying balls
Integer HasBalls(CSmPlayer _Player) {
	if (_Player == Null) return 0;
	declare BallCount = 0;
	foreach (Object in _Player.Objects) {
		if (G_BallObjectsIds.exists(Object.Id)) {
			BallCount += 1;
		}
	}
	return BallCount;
}

// Get first ball carried by the player
CSmObject GetBall(CSmPlayer _Player) {
	if (_Player == Null) return Null;
	foreach (Object in _Player.Objects) {
		if (G_BallObjectsIds.exists(Object.Id)) {
			return Object;
		}
	}
	return Null;
}

// Unspawn all given object ids
Void UnspawnObjects(Ident[] _ObjectIds) {
	foreach (ObjectId in _ObjectIds) {
		if (!Objects.existskey(ObjectId)) continue;
		declare Object <=> Objects[ObjectId];
		declare Boolean AtHome for Object;
		AtHome = False;
		Object.SetUnspawned();
	}
}

// Build player name subtext
Text GetColorizedPlayerName(CSmPlayer _Player) {
	if (_Player == Null) return "";
	declare TeamColor = "";
	if (Teams.existskey(_Player.CurrentClan-1)) TeamColor = Teams[_Player.CurrentClan-1].ColorText;
	return "$<"^TeamColor^"> $<"^_Player.Name^"$>$>";
}

// Update hud3dmarkers
// None, Never, Always, WhenInFrustum, WhenVisible, WhenInMiddleOfScreen
Void UpdateHud3dMarkers(Boolean _UseObjectId) {
	declare MarkersXml = "";

	// Ball marker
	foreach (Index => BallObjectId in G_BallObjectsIds) {
		if (!Objects.existskey(BallObjectId)) continue;
		declare BallObject <=> Objects[BallObjectId];
		if (_UseObjectId) {
			MarkersXml ^= """<marker objectid="{{{BallObject.Id}}}" manialinkframeid="Frame_BallMarker{{{Index}}}" box="0 1.2 0"/>
				<marker objectid="{{{BallObject.Id}}}" manialinkframeid="Frame_BallMarkerHelp{{{Index}}}"
					visibility="WhenInMiddleOfScreen" box="0 1.2 0"/>""";
		} else if (BallObject.Player != Null) {
			MarkersXml ^= """<marker playerlogin="{{{BallObject.Player.Login}}}" manialinkframeid="Frame_BallMarker{{{Index}}}" box="0 1.2 0"/>
				<marker playerlogin="{{{BallObject.Player.Login}}}" manialinkframeid="Frame_BallMarkerHelp{{{Index}}}"
					visibility="WhenInMiddleOfScreen" box="0 1.2 0"/>""";
		} else {
			MarkersXml ^= """<marker pos="{{{Tools::GetPosn(BallObject.Position)}}}" manialinkframeid="Frame_BallMarker{{{Index}}}" box="0 1.2 0"/>
				<marker pos="{{{Tools::GetPosn(BallObject.Position)}}}" manialinkframeid="Frame_BallMarkerHelp{{{Index}}}"
					visibility="WhenInMiddleOfScreen" box="0 1.2 0"/>""";
		}
	}
	
	// Gauge markers
	foreach (Landmark in MapLandmarks_Gauge) {
		if (Landmark.Tag != "Goal") continue;
		if (Landmark.Order == 1 || Landmark.Order == 2) {
			MarkersXml ^= """<marker manialinkframeid="Frame_GaugeMarker{{{Landmark.Order}}}" box="0 6.5 0" visibility="WhenInFrustum"
				pos="{{{Landmark.Position[0]}}} {{{Landmark.Position[1]}}} {{{Landmark.Position[2]}}}"/>""";
		}
	}

	Markers::Add(MarkersXml);
}

// Send hit message
Void SendHitMessage(CSmModeEvent _Event, Boolean _Pass) {
	if (_Event == Null || _Event.Shooter == Null || _Event.Victim == Null) return;
	if (_Event.Type != CSmModeEvent::EType::OnHit) return;
	declare Distance = MathLib::Distance(_Event.Shooter.Position, _Event.Victim.Position);
	if (Distance < C_HitMessageMinDist) return;
	declare UI <=> UIManager.GetUI(_Event.Shooter);
	if (UI == Null) return;
	// Send message
	Distance = MathLib::NearestInteger(Distance * 10) / 10.;
	declare Text Message;
	if (_Pass) {
		// Long range pass
		Message = TextLib::Compose(_("%1m Pass!"), TextLib::ToText(Distance));
	} else {
		// Long range hit
		Message = TextLib::Compose(_("%1m Hit!"), TextLib::ToText(Distance));
	}
	UI.SendNotice(Message,
		CUIConfig::ENoticeLevel::MapInfo, _Event.Shooter.User, CUIConfig::EAvatarVariant::Default,
		CUIConfig::EUISound::Silence, 0);
}

// Return the capture time dependent on current phase
Integer GetCaptureTime() {
	switch (G_Phase) {
		case 1: {
			// Reduction phase
			declare LeftTime = (UIManager.UIAll.CountdownEndTime - Now + Period) * 1.;
			declare MaxTime = S_TimeLimitReduction * 1000.;
			declare Factor = LeftTime / MaxTime;
			return MathLib::CeilingInteger(S_DefaultCaptureTime * Factor * 1000.);
		}
		case 2: {
			// Instant phase
			return 1;
		}
	}
	return MathLib::NearestInteger(S_DefaultCaptureTime * 1000.);
}

// Calculate speed from velocity vecotr
Real GetSpeed(Vec3 _Vel) {
	declare Speed = 0.;
	for (Index, 0, 2) {
		Speed += MathLib::Abs(_Vel[Index]);
	}
	return Speed;
}

// Returns the remaining time of the dropped ball until it resets
Integer GetRmDrpdBallTime(CSmObject _Ball) {
	if (_Ball == Null || _Ball.Player != Null) return 0;
	declare DropTime for _Ball = -1;
	if (DropTime < 0) return 0;
	declare Speed = GetSpeed(_Ball.Vel);
	declare RestTime for _Ball = -1;
	if (Speed > 0.4) {
		RestTime = -1;
		return 0;
	}
	if (RestTime < DropTime) {
		RestTime = Now;
		return 0;
	}
	return C_DroppedBallResetTime - Now + RestTime;
}

// Updates global net variables
Void UpdateNetVariables() {
	declare netwrite Integer Net_StartTime for Teams[0];
	declare netwrite Integer Net_Phase for Teams[0];
	declare netwrite Text[Integer] Net_BallCarrierName for Teams[0];
	declare netwrite Integer[Integer] Net_BallCarrierClan for Teams[0];
	
	Net_StartTime = StartTime;
	Net_Phase = G_Phase;
	
	foreach (Index => BallObjectId in G_BallObjectsIds) {
		if (!Objects.existskey(BallObjectId)) continue;
		declare BallObject <=> Objects[BallObjectId];
		if (BallObject.Player != Null) {
			Net_BallCarrierName[Index] = BallObject.Player.Name;
			Net_BallCarrierClan[Index] = BallObject.Player.CurrentClan;
		} else {
			declare AtHome for BallObject = False;
			if (AtHome) {
				Net_BallCarrierName[Index] = " ";
			} else {
				Net_BallCarrierName[Index] = "";
			}
			Net_BallCarrierClan[Index] = 0;
			declare netwrite Integer[Integer] Net_RemainingDropTime for Teams[0];
			Net_RemainingDropTime[Index] = GetRmDrpdBallTime(BallObject);
		}
	}
}

// Increase scores of the given player
Void AddPoints(CSmPlayer _Player, Integer _Points) {
	if (_Player == Null || _Player.Score == Null) return;
	_Player.Score.RoundPoints += _Points;
	_Player.Score.Points += _Points;
//bye
//	ScoresTable::SetFooterScore(_Player, TextLib::Compose("%1: %2		%3: %4",
//		_("|A Round of the Match|Round"), TextLib::ToText(_Player.Score.RoundPoints),
//		_("|Total Points|Total"), TextLib::ToText(_Player.Score.Points)));
}

// Update damage of the given player
Void UpdateDamage(CSmPlayer _Player, Integer _Points) {
	if (_Player == Null || _Player.Score == Null) return;
	declare Damage for _Player.Score = 0;
	declare Top_Damage for _Player.Score = 0;
	if (_Points == 0) {
		Damage = 0;
	} else {
		Damage += _Points;
		Top_Damage += _Points;
	}
//bye
	if (Top_Damage > 0) {
//		ScoresTable::SetCustom2(_Player, TextLib::ToText(Damage));
		Top::SetRecord(_Player, T_Damage, TextLib::ToText(Top_Damage), -Top_Damage);
	} else {
//		ScoresTable::SetCustom2(_Player, "");
	}
}

// Update passes of the given player
Void UpdatePasses(CSmPlayer _Player, Integer _Points) {
	if (_Player == Null || _Player.Score == Null) return;
	declare Passes for _Player.Score = 0;
	declare Top_Passes for _Player.Score = 0;
	if (_Points == 0) {
		Passes = 0;
	} else {
		Passes += _Points;
		Top_Passes += _Points;
	}
//bye
	if (Passes > 0) {
//		ScoresTable::SetCustom3(_Player, TextLib::ToText(Passes));
		Top::SetRecord(_Player, T_Passes, TextLib::ToText(Top_Passes), -Top_Passes);
	} else {
//		ScoresTable::SetCustom3(_Player, "");
	}
}

// Update captures of the given player
Void UpdateCaptures(CSmPlayer _Player, Integer _Captures) {
	if (_Player == Null || _Player.Score == Null) return;
	declare Top_Captures for _Player.Score = 0;
	if (_Captures == 0) {
		Top_Captures = 0;
	} else {
		Top_Captures += _Captures;
	}
	if (Top_Captures > 0) {
		Top::SetRecord(_Player, T_Captures, TextLib::ToText(Top_Captures), -Top_Captures);
	}
}

// Update ball hits of the given player
Void UpdateBallHits(CSmPlayer _Player, Integer _Hits) {
	if (_Player == Null || _Player.Score == Null) return;
	declare Top_BallHits for _Player.Score = 0;
	if (_Hits == 0) {
		Top_BallHits = 0;
	} else {
		Top_BallHits += _Hits;
	}
	if (Top_BallHits > 0) {
		Top::SetRecord(_Player, T_BallHitters, TextLib::ToText(Top_BallHits), -Top_BallHits);
	}
}

// Update back stabs of the given player
Void UpdateBackStabs(CSmPlayer _Player, Integer _Stabs) {
	if (_Player == Null || _Player.Score == Null) return;
	declare Top_BackStabs for _Player.Score = 0;
	if (_Stabs == 0) {
		Top_BackStabs = 0;
	} else {
		Top_BackStabs += _Stabs;
	}
	if (Top_BackStabs > 0) {
		Top::SetRecord(_Player, T_BackStabber, TextLib::ToText(Top_BackStabs), -Top_BackStabs);
	}
}

// Update capture % sum of the given player
Void UpdateCaptureTotal(CSmPlayer _Player, Integer _Progress) {
	if (_Player == Null || _Player.Score == Null) return;
	declare Top_CaptureSum for _Player.Score = 0;
	if (_Progress == 0) {
		Top_CaptureSum = 0;
	} else {
		Top_CaptureSum += _Progress;
	}
	if (Top_CaptureSum > 0) {
		declare CaptureProgress = MathLib::NearestInteger(100. * MathLib::ToReal(Top_CaptureSum) / (S_DefaultCaptureTime * 1000.));
		Top::SetRecord(_Player, T_CaptureTotal, TextLib::ToText(CaptureProgress)^"%", -CaptureProgress);
	}
}

// Reset all match tops
Void ResetMatchTops() {
	foreach (Player in AllPlayers) {
		if (Player.Score == Null) continue;
		
		declare Integer Top_Damage for Player.Score;
		declare Integer Top_Passes for Player.Score;
		declare Integer Top_Captures for Player.Score;
		declare Integer Top_BallHits for Player.Score;
		declare Integer Top_BackStabs for Player.Score;
		declare Integer Top_CaptureSum for Player.Score;
		
		Top_Damage = 0;
		Top_Passes = 0;
		Top_Captures = 0;
		Top_BallHits = 0;
		Top_BackStabs = 0;
		Top_CaptureSum = 0;
		
		UpdatePasses(Player, 0);
		UpdateCaptures(Player, 0);
		UpdateDamage(Player, 0);
		UpdateBallHits(Player, 0);
		UpdateBackStabs(Player, 0);
		UpdateCaptureTotal(Player, 0);
	}
}

// Reset all round tops
Void ResetRoundTops() {
	foreach (Player in AllPlayers) {
		if (Player.Score == Null) continue;
		AddPoints(Player, 0);
		UpdatePasses(Player, 0);
		UpdateDamage(Player, 0);
	}
}

// Update teams ball possession
Void UpdateStatBallPossession(Integer _Clan, Integer _Time) {
	if (!Teams.existskey(_Clan) || !Teams.existskey(1 - _Clan)) return;
	declare Stat_BallPoss as Stat_BallPoss0 for Teams[_Clan] = 0;
	if (_Time == 0) {
		Stat_BallPoss0 = 0;
		TeamStats::SetStat(T_BallPoss, _Clan, "0%");
		TeamStats::SetStat(T_BallPoss, 1 - _Clan, "0%");
	} else {
		Stat_BallPoss0 += _Time;
		declare Possession = 0;
		if (Stat_BallPoss0 > 0) {
			declare Stat_BallPoss as Stat_BallPoss1 for Teams[1 - _Clan] = 0;
			Possession = MathLib::NearestInteger((100. * Stat_BallPoss0) / (1. * (Stat_BallPoss0 + Stat_BallPoss1)));
		}
		TeamStats::SetStat(T_BallPoss, _Clan, TextLib::Compose("%1%2", TextLib::ToText(Possession), "%"));
		TeamStats::SetStat(T_BallPoss, 1 - _Clan, TextLib::Compose("%1%2", TextLib::ToText(100 - Possession), "%"));
	}
}

// Update teams damage
Void UpdateStatDamage(Integer _Clan, Integer _Damage) {
	if (!Teams.existskey(_Clan)) return;
	declare Stat_Damage for Teams[_Clan] = 0;
	if (_Damage == 0) {
		Stat_Damage = 0;
	} else {
		Stat_Damage += _Damage;
	}
	TeamStats::SetStat(T_Damage, _Clan, TextLib::ToText(Stat_Damage));
}

// Update teams passes
Void UpdateStatPasses(Integer _Clan, Integer _Passes) {
	if (!Teams.existskey(_Clan)) return;
	declare Stat_Passes for Teams[_Clan] = 0;
	if (_Passes == 0) {
		Stat_Passes = 0;
	} else {
		Stat_Passes += _Passes;
	}
	TeamStats::SetStat(T_Passes, _Clan, TextLib::ToText(Stat_Passes));
}

// Update teams capture tries
Void UpdateStatCaptureTries(Integer _Clan, Integer _Tries) {
	if (!Teams.existskey(_Clan)) return;
	declare Stat_CaptureTries for Teams[_Clan] = 0;
	if (_Tries == 0) {
		Stat_CaptureTries = 0;
	} else {
		Stat_CaptureTries += _Tries;
	}
	TeamStats::SetStat(T_CaptureTries, _Clan, TextLib::ToText(Stat_CaptureTries));
}

// Update teams enemy kills
Void UpdateStatEnemyKills(Integer _Clan, Integer _Kills) {
	if (!Teams.existskey(_Clan)) return;
	declare Stat_EnemyKills for Teams[_Clan] = 0;
	if (_Kills == 0) {
		Stat_EnemyKills = 0;
	} else {
		Stat_EnemyKills += _Kills;
	}
	TeamStats::SetStat(T_EnemyKills, _Clan, TextLib::ToText(Stat_EnemyKills));
}

// Update teams team kills
Void UpdateStatTeamKills(Integer _Clan, Integer _Kills) {
	if (!Teams.existskey(_Clan)) return;
	declare Stat_TeamKills for Teams[_Clan] = 0;
	if (_Kills == 0) {
		Stat_TeamKills = 0;
	} else {
		Stat_TeamKills += _Kills;
	}
	TeamStats::SetStat(T_TeamKills, _Clan, TextLib::ToText(Stat_TeamKills));
}

// Reset team statistics
Void ResetStatistics() {
	foreach (Clan => Team in Teams) {
		UpdateStatBallPossession(Clan, 0);
		UpdateStatDamage(Clan, 0);
		UpdateStatPasses(Clan, 0);
		UpdateStatCaptureTries(Clan, 0);
		UpdateStatEnemyKills(Clan, 0);
		UpdateStatTeamKills(Clan, 0);
	}
}

// Spawn player
Void MySpawnPlayer(CSmPlayer _Player) {
	if (_Player == Null) return;
	UnspawnPlayer(_Player);
	if (_Player.RequestsSpectate) return;
	
	// Set values
	_Player.ThrowSpeed = C_ThrowSpeed;
	
	// Set player weapon
	switch (S_Mode) {
		case 1: {
			SetPlayerWeapon(_Player, CSmMode::EWeapon::Laser, False);
		}
		case 2: {
			declare WeaponNb = MathLib::Rand(1, 4);
			switch (WeaponNb) {
				case 2: {
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Laser, True);
				}
				case 3: {
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Nucleus, True);
				}
				case 4: {
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Arrow, True);
				}
				default: {
					SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
				}
			}
		}
		default: {
			SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
		}
	}
	
	// Calculate spawn time
	declare SpawnTime = StartTime;
	if (Now > SpawnTime) {
		SpawnTime = Now + 3000;
	}
	
	// Determine spawn landmark
	declare SpawnIds = G_ClanSpawnLandmarkIds[_Player.RequestedClan];
	declare SpawnIndex = 0;
	if (G_LastSpawnIndex.existskey(_Player.RequestedClan)) {
		SpawnIndex = G_LastSpawnIndex[_Player.RequestedClan] + 1;
		if (SpawnIndex >= SpawnIds.count) {
			SpawnIndex = 0;
		}
	}
	G_LastSpawnIndex[_Player.RequestedClan] = SpawnIndex;
	SM::SpawnPlayer(_Player, _Player.RequestedClan, MapLandmarks_PlayerSpawn[SpawnIds[SpawnIndex]].PlayerSpawn, SpawnTime);
}

// Set clans of spawns and gauges at start of map and each round (changing sides)
Void AssignSpawnsGaugesClans() {
	// SPAWNS
	// Change sides
	declare FirstSpawns = G_ClanSpawnLandmarkIds[1];
	G_ClanSpawnLandmarkIds[1] = G_ClanSpawnLandmarkIds[2];
	G_ClanSpawnLandmarkIds[2] = FirstSpawns;
	// Assign clans
	foreach (Clan => SpawnLandmarkIds in G_ClanSpawnLandmarkIds) {
		foreach (Index => Id in SpawnLandmarkIds) {
			switch (MapLandmarks_PlayerSpawn[Id].Base.Clan) {
				case 0: {
					if (Clan != 3) {
						MapLandmarks_PlayerSpawn[Id].Base.Clan = Clan;
					}
				}
				default: {
					MapLandmarks_PlayerSpawn[Id].Base.Clan = 3 - MapLandmarks_PlayerSpawn[Id].Base.Clan;
				}
			}
		}
	}
	
	// GAUGES
	// Edit ball gauge
	if (MapLandmarks_Gauge.existskey(G_BallLandmarkId)) {
		MapLandmarks_Gauge[G_BallLandmarkId].Base.Clan = 0;
		MapLandmarks_Gauge[G_BallLandmarkId].Gauge.Clan = 0;
	}
	
	// Change sides
	declare FirstGauge = G_ClanGaugeLandmarkIds[1];
	G_ClanGaugeLandmarkIds[1] = G_ClanGaugeLandmarkIds[2];
	G_ClanGaugeLandmarkIds[2] = FirstGauge;
	// Prepare gauge stuff
	foreach (Order => GaugeLandmarkId in G_ClanGaugeLandmarkIds) {
		declare GaugeLandmark <=> MapLandmarks_Gauge[GaugeLandmarkId];
		
		// Initialize values
		GaugeLandmark.Gauge.Captured = False;
		GaugeLandmark.Gauge.ValueReal = 0.;
		GaugeLandmark.Gauge.Speed = 0;
		
		// Assign clans
		switch (GaugeLandmark.Gauge.Clan) {
			case 0: {
				if (Order != 3) {
					GaugeLandmark.Gauge.Clan = Order;
					GaugeLandmark.Base.Clan = GaugeLandmark.Gauge.Clan;
				}
			}
			default: {
				GaugeLandmark.Gauge.Clan = 3 - GaugeLandmark.Gauge.Clan;
				GaugeLandmark.Base.Clan = GaugeLandmark.Gauge.Clan;
			}
		}
	}
}

// Update clans of bases
Void UpdateBaseClans() {
	if (!G_BallObjectsIds.existskey(0) || !Objects.existskey(G_BallObjectsIds[0])) return;
	declare BallObject <=> Objects[G_BallObjectsIds[0]];
	if (G_BallObjectsIds.count > 1 || BallObject.Player == Null) {
		// Ball dropped - Reset base clan of the ball landmark
		if (MapLandmarks_Gauge.existskey(G_BallLandmarkId)) {
			declare BallLandmark <=> MapLandmarks_Gauge[G_BallLandmarkId];
			BallLandmark.Base.Clan = 0;
			BallLandmark.Gauge.Clan = 0;
		}
	} else {
		// A clan carries the ball - Set carrying clan to ball landmark
		if (MapLandmarks_Gauge.existskey(G_BallLandmarkId)) {
			declare BallLandmark <=> MapLandmarks_Gauge[G_BallLandmarkId];
			BallLandmark.Base.Clan = BallObject.Player.CurrentClan;
			BallLandmark.Gauge.Clan = BallObject.Player.CurrentClan;
		}
		// Bases screw things up on some maps - Perform fix if needed
		if (G_ClanGaugeLandmarkIds.existskey(1) && MapLandmarks_Gauge.existskey(G_ClanGaugeLandmarkIds[1])
			&& G_ClanGaugeLandmarkIds.existskey(2) && MapLandmarks_Gauge.existskey(G_ClanGaugeLandmarkIds[2])) {
			if (MapLandmarks_Gauge[G_ClanGaugeLandmarkIds[1]].Base == MapLandmarks_Gauge[G_ClanGaugeLandmarkIds[2]].Base) {
				// Gauges of the teams share the same base -.-
				// Change the clan of the base to the clan currently carrying the ball
				if (G_ClanGaugeLandmarkIds.existskey(BallObject.Player.CurrentClan)
					&& MapLandmarks_Gauge.existskey(G_ClanGaugeLandmarkIds[BallObject.Player.CurrentClan])) {
					MapLandmarks_Gauge[G_ClanGaugeLandmarkIds[BallObject.Player.CurrentClan]].Base.Clan = BallObject.Player.CurrentClan;
				}
			}
		}
	}
}

// Player picks up the ball
Boolean PickUpBall(CSmPlayer _Player, CSmObject _Object) {
	// Perform several checks if picking up is allowed right now because of weird bugs of the game itself
	if (_Player == Null || _Object == Null || _Object.Player != Null || !G_BallObjectsIds.exists(_Object.Id)) return False;
	if ((Now > EndTime && EndTime > StartTime) || Now < StartTime) return False;
	if (_Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned || _Player.Armor <= 0) return False;
	if (!C_BotsCanHaveBall && _Player.IsFakePlayer) return False;
				
	_Object.SetPlayer(_Player);
	declare Ident PlayerId for _Object;
	PlayerId = _Player.Id;
	declare Boolean AtHome for _Object;
	AtHome = False;
	
	Message::SendBigMessage(TextLib::Compose(_("%1 has the %2Ball%3!"),
		GetColorizedPlayerName(_Player), "$<"^Teams[_Player.CurrentClan - 1].ColorText, "$>"),
		3000, 2, CUIConfig::EUISound::PhaseChange, 0);
	AddPoints(_Player, 2);
	UpdateBaseClans();
	
	// Update markers
	UpdateHud3dMarkers(False);
	
	return True;
}

Void ResetBall(CSmObject _Ball) {
	if (_Ball == Null) return;
	_Ball.SetPositionAndVel(MapLandmarks_Gauge[G_BallLandmarkId].Position, <0., 0., 0.>);
	
	declare Ident PlayerId for _Ball;
	PlayerId = NullId;
	declare Integer DropTime for _Ball;
	DropTime = -1;
	declare Boolean AtHome for _Ball;
	AtHome = True;
	
	// Update markers
	UpdateHud3dMarkers(False);
	
	Message::SendBigMessage(_("The Ball has been reset!"), 3000, 1, CUIConfig::EUISound::PhaseChange, 1);
	UpdateBaseClans();
}

// Ball carrier drops the ball
Void DropBall(CSmObject _Ball, Vec3 _Position) {
	if (_Ball == Null) return;
	// Perform drop
	declare Ident PlayerId for _Ball;
	PlayerId = NullId;
	declare Integer DropTime for _Ball;
	DropTime = Now;
	declare Integer LastBallResetSeconds for _Ball;
	LastBallResetSeconds = MathLib::CeilingInteger(C_DroppedBallResetTime / 1000.);
	
	declare Text Message;
	if (_Ball.Player == Null) {
		Message = _("The Ball has been dropped!");
	} else {
		Message = TextLib::Compose(_("%1 dropped the Ball!"), GetColorizedPlayerName(_Ball.Player));
	}
	Message::SendBigMessage(Message, 3000, 2, CUIConfig::EUISound::PhaseChange, 0);
	
	_Ball.SetPositionAndVel(_Position + <0., 1., 0.>, <0., 1., 0.>);
	UpdateBaseClans();
	
	// Update markers
	UpdateHud3dMarkers(False);
}

// Drop all balls carried by the player
Void DropBalls(CSmPlayer _Player) {
	if (_Player == Null) return;
	declare ObjectIds = Ident[];
	foreach (Object in _Player.Objects) {
		if (G_BallObjectsIds.exists(Object.Id)) {
			// Ball carrier requested respawn -> Drop the ball
			ObjectIds.add(Object.Id);
		}
	}
	for (Index, 0, ObjectIds.count-1) {
		if (!Objects.existskey(ObjectIds[Index])) continue;
		DropBall(Objects[ObjectIds[Index]], _Player.Position);
	}
	
	// Update markers
	UpdateHud3dMarkers(False);
}

// Player passes the ball
Void PassBall(CSmPlayer _Shooter, CSmPlayer _Victim, CSmObject _Ball) {
	// Perform several checks if passing is allowed right now because of weird event bugs of the game itself
	if (_Shooter == Null || _Victim == Null || _Ball == Null) return;
	if (Now < StartTime || StartTime < 0) return;
	if (_Ball.Player != _Shooter) return;
	if (_Victim.StartTime > Now || _Victim.Armor <= 0 || (!C_BotsCanHaveBall && _Victim.IsFakePlayer)) return;
	if (_Shooter.Armor <= 0) {
		DropBall(_Ball, _Shooter.Position);
		return;
	}
	
	// Pass the ball
	declare Ident PlayerId for _Ball;
	PlayerId = _Victim.Id;
	_Ball.SetPlayer(_Victim);
	
	Message::SendBigMessage(TextLib::Compose(_("%1 has the %2Ball%3!"),
		GetColorizedPlayerName(_Victim),
		"$<"^Teams[_Victim.CurrentClan-1].ColorText, "$>"), 3000, 2, CUIConfig::EUISound::Warning, 0);
	
	if (_Shooter.CurrentClan == _Victim.CurrentClan) {
		// Team pass -> Grant points!
		AddPoints(_Shooter, 2);
		UpdatePasses(_Shooter, 1);
		UpdateStatPasses(_Shooter.CurrentClan - 1, 1);
		if (!_Shooter.IsFakePlayer) {
			XmlRpc.SendCallback("passBall", "Shooter:"^_Shooter.Login^";Victim:"^_Victim.Login);
		}
	} else {
		// Pass to opponent
		UpdateBaseClans();
	}
	
	// Update markers
	UpdateHud3dMarkers(False);
}

// Updates clan scores at the top
Void UpdateClanScoresSummary(Boolean _Tolerant) {
	declare PlayerClan1Id = NullId;
	declare PlayerClan2Id = NullId;
	foreach (Player in Players) {
		if (PlayerClan1Id == NullId && (Player.CurrentClan == 1 || _Tolerant && Player.RequestedClan == 1)) {
			PlayerClan1Id = Player.Id;
		} else {
			if (PlayerClan2Id == NullId && (Player.CurrentClan == 2 || _Tolerant && Player.RequestedClan == 2)) {
				PlayerClan2Id = Player.Id;
			} else {
				if (PlayerClan1Id != NullId && PlayerClan2Id != NullId) {
					break;
				}
			}
		}
	}
	if (PlayerClan1Id != NullId && PlayerClan2Id != NullId) {
		UIManager.UIAll.OverlayScoreSummary = True;
		UIManager.UIAll.ScoreSummary_Player1 = PlayerClan1Id;
		UIManager.UIAll.ScoreSummary_Points1 = ClanScores[Players[PlayerClan1Id].RequestedClan];
		UIManager.UIAll.ScoreSummary_Player2 = PlayerClan2Id;
		UIManager.UIAll.ScoreSummary_Points2 = ClanScores[Players[PlayerClan2Id].RequestedClan];
		if (G_MaxCapturePercentage.existskey(1)) {
			UIManager.UIAll.ScoreSummary_Gauge1 = G_MaxCapturePercentage[1];
		} else {
			UIManager.UIAll.ScoreSummary_Gauge1 = 0.;
		}
		if (G_MaxCapturePercentage.existskey(2)) {
			UIManager.UIAll.ScoreSummary_Gauge2 = G_MaxCapturePercentage[2];
		} else {
			UIManager.UIAll.ScoreSummary_Gauge2 = 0.;
		}
		if (S_BestOfXMatch > 0) {
			UIManager.UIAll.ScoreSummary_MatchPoints1 = G_ClanMapScores[Players[PlayerClan1Id].RequestedClan];
			UIManager.UIAll.ScoreSummary_MatchPoints2 = G_ClanMapScores[Players[PlayerClan2Id].RequestedClan];
		} else {
			UIManager.UIAll.ScoreSummary_MatchPoints1 = -1;
			UIManager.UIAll.ScoreSummary_MatchPoints2 = -1;
		}
	} else {
		if (!_Tolerant) {
			UpdateClanScoresSummary(True);
		} else {
			UIManager.UIAll.OverlayScoreSummary = False;
		}
	}
}

// Create the extra layer manialink
Text CreateLayerExtra() {
	declare BarImageUrl = "file://Media/Images/Common/GreenBar.png";
	declare Manialink = """<script><!--
		#Include "MathLib" as MathLib
		#Include "TextLib" as TextLib
		
		main() {
			wait(InputPlayer != Null);
				
			declare Label_Phase					<=> (Page.GetFirstChild("Label_Phase") as CMlLabel);
			declare Quad_BallCarrierHighlight	<=> (Page.GetFirstChild("Quad_BallCarrierHighlight") as CMlQuad);
			
			declare Frame_BallCarrier		<=> (Page.GetFirstChild("Frame_BallCarrier") as CMlFrame);
			declare Label_BallCarrier		<=> (Frame_BallCarrier.GetFirstChild("Label_BallCarrier") as CMlLabel);
			declare Frame_TeamBar			<=> (Frame_BallCarrier.GetFirstChild("Frame_TeamBar") as CMlFrame);
			declare Quads_TeamBar1			<=> (Frame_TeamBar.GetFirstChild("Quad_TeamBar1") as CMlQuad);
			declare Quads_TeamBar2			<=> (Frame_TeamBar.GetFirstChild("Quad_TeamBar2") as CMlQuad);
			
			declare Frame_Crosshair			<=> (Page.GetFirstChild("Frame_Crosshair") as CMlFrame);
			declare Label_CrosshairTop		<=> (Frame_Crosshair.GetFirstChild("Label_CrosshairTop") as CMlLabel);
			declare Label_CrosshairBottom	<=> (Frame_Crosshair.GetFirstChild("Label_CrosshairBottom") as CMlLabel);
			
			declare Frame_Capturing			<=> (Page.GetFirstChild("Frame_Capturing") as CMlFrame);
			declare Label_Capturing			<=> (Frame_Capturing.GetFirstChild("Label_Capturing") as CMlLabel);
			declare Gauge_Capturing			<=> (Frame_Capturing.GetFirstChild("Gauge_Capturing") as CMlGauge);
			
			declare ShowHighlight	for LocalUser = True;
			
			declare netread Net_BallLandmarkIndex	for Teams[0] = -1;
			
			declare netread Net_StartTime	for Teams[0] = -1;
			declare netread Net_Phase		for Teams[0] = -1;
			
			declare netread Net_BallCarrierClan		for Teams[0] = Integer[Integer];
			declare netread Net_BallCarrierName		for Teams[0] = Text[Integer];
			declare netread Net_RemainingDropTime	for Teams[0] = Integer[Integer];
			
			declare LastCapturedTime = -1;
			
			declare LastUIUpdate = -1;
			
			while (True) {
				yield;
				
				declare CurrentPlayer <=> InputPlayer;
				if (GUIPlayer != Null) CurrentPlayer <=> GUIPlayer;
				
				foreach (Event in PendingEvents) {
					switch (Event.Type) {
						case CMlEvent::Type::KeyPress: {
							switch (Event.KeyCode) {
								case 39: {
									ShowHighlight = !ShowHighlight;
								}
							}
						}
					}
				}
				
				// Capturing gauge
				declare ShowGauge = False;
				if ((Net_StartTime > 0 && Net_StartTime < ArenaNow) || LastCapturedTime > 0) {
					foreach (Index => GaugeLandmark in MapLandmarks_Gauge) {
						if (Index == Net_BallLandmarkIndex || Net_BallLandmarkIndex < 0) continue;
						if (GaugeLandmark.Gauge.ValueReal <= 0.) continue;
						
						declare Value = MathLib::FloorInteger(GaugeLandmark.Gauge.ValueReal * 100.);
						if (Value <= 0) continue;
						
						if (Value >= 100 && !GaugeLandmark.Gauge.Captured) Value -= 1;
						Label_Capturing.Value = Value^"%";
						Gauge_Capturing.SetRatio(GaugeLandmark.Gauge.ValueReal);
						Gauge_Capturing.SetClan(GaugeLandmark.Gauge.Clan);
						LastCapturedTime = Now;
						if (GaugeLandmark.Gauge.Captured) LastCapturedTime += 500;
						break;
					}
				}
				if (LastCapturedTime + 650 > Now) {
					ShowGauge = True;
				} else {
					LastCapturedTime = -1;
				}
				Frame_Capturing.Visible = ShowGauge;
				
				if (LastUIUpdate + 250 > Now) continue;
				LastUIUpdate = Now;
				
				// Hide stuff between rounds
				Frame_BallCarrier.Visible = (Net_StartTime > 0);
				
				// Phase display
				if (Net_StartTime < 0 || Net_Phase < 0 && Net_Phase > 2) {
					Label_Phase.Visible = False;
				} else {
					Label_Phase.Visible = True;
					switch (Net_Phase) {
						case 1: {
							Label_Phase.Value = TextLib::Compose("$fc3%1", _("Reduction Phase!"));
						}
						case 2: {
							Label_Phase.Value = TextLib::Compose("$f60%1", _("Instant Phase!"));
						}
						default: {
							Label_Phase.Value = _("Normal Phase");
						}
					}
				}
				
				// Crosshair extension
				if (Net_StartTime > 0 && Net_BallCarrierName.existskey(0) && Net_BallCarrierClan.existskey(0)
					&& CurrentPlayer.Name == Net_BallCarrierName[0] && Teams.existskey(Net_BallCarrierClan[0] - 1)) {
					Frame_Crosshair.Visible = True;
					Label_CrosshairTop.Value = Teams[Net_BallCarrierClan[0] - 1].ColorText^"      ";
					Label_CrosshairBottom.Value = TextLib::Compose(Teams[Net_BallCarrierClan[0] - 1].ColorText^"$n$o%1", _("shoot to pass"));
					Quad_BallCarrierHighlight.Visible = (True && ShowHighlight);
					Quad_BallCarrierHighlight.Colorize = Teams[Net_BallCarrierClan[0] - 1].ColorPrimary;
				} else {
					Frame_Crosshair.Visible = False;
					Quad_BallCarrierHighlight.Visible = False;
				}
				
				// Ball carrier display
				if (!Net_BallCarrierName.existskey(0)) continue;
				switch (Net_BallCarrierName[0]) {
					case " ": {
						Frame_TeamBar.Visible = False;
						Label_BallCarrier.Value = _("Home");
					}
					case "": {
						Frame_TeamBar.Visible = False;
						declare DropText = "";
						if (Net_RemainingDropTime.existskey(0) && Net_RemainingDropTime[0] > 0) {
							DropText = " ("^((Net_RemainingDropTime[0] + 300) / 1000)^")";
						}
						Label_BallCarrier.Value = TextLib::Compose("%1%2", _("Dropped"), DropText);
					}
					default: {
						if (Net_BallCarrierClan.existskey(0) && Teams.existskey(Net_BallCarrierClan[0] - 1)) {
							Frame_TeamBar.Visible = True;
							foreach (Control in Frame_TeamBar.Controls) {
								declare Quad <=> (Control as CMlQuad);
								Quad.Colorize = Teams[Net_BallCarrierClan[0] - 1].ColorPrimary;
							}
							Label_BallCarrier.Value = "$<"^Teams[Net_BallCarrierClan[0] - 1].ColorText^"$<"^Net_BallCarrierName[0]^"$>$>";
						} else {
							Frame_TeamBar.Visible = False;
							Label_BallCarrier.Value = Net_BallCarrierName[0];
						}
					}
				}
			}
		}
		--></script>
		<label id="Label_Phase" posn="0 89 50" sizen="30 0" textsize="1" scale="0.8" hidden="1" halign="center" valign="center2"/>
		<quad id="Quad_BallCarrierHighlight" posn="0 0 -30" sizen="320 180" hidden="1" halign="center" valign="center2"
			image="file://Media/Images/SpeedBall/BallCarrierFilter1.png" opacity="0.6"/>
		
		<frame id="Frame_BallCarrier" posn="110 -65" hidden="1">
			<quad posn="0 0 0" sizen="55 8" style="Bgs1InRace" substyle="BgWindow3" halign="center" valign="center2"/>
			<label id="Label_BallCarrier" posn="0 0 2" sizen="50 7" textprefix="$000" halign="center" valign="center2"/>
			<frame id="Frame_TeamBar" hidden="1">
				<quad id="Quad_TeamBar1" posn="-26 0 1" sizen="1 6" image="{{{BarImageUrl}}}" opacity="0.9" halign="center" valign="center2"/>
				<quad id="Quad_TeamBar2" posn="26 0 1" sizen="1 6" image="{{{BarImageUrl}}}" opacity="0.9" halign="center" valign="center2"/>
			</frame>
		</frame>
		
		<frame id="Frame_Crosshair" hidden="1">
			<label id="Label_CrosshairTop" posn="0 7" scale="2" halign="center" valign="center2"/>
			<label id="Label_CrosshairBottom" posn="0 -8.5" scale="1" style="TextCardSmallScores2" halign="center" valign="center2"/>
		</frame>
		
		<frame id="Frame_Capturing" hidden="1">
			<label id="Label_Capturing" posn="0 -25" scale="2" textprefix="$o" halign="center" valign="center2"/>
			<gauge id="Gauge_Capturing" posn="0 -35" sizen="110 8" style="EnergyBar" halign="center" valign="center2"/>
		</frame>""";
	return Manialink;
}

// Creates message for near miss
Text GetNearMissMessage(CSmModeEvent _Event) {
	// Catch invalid events
	if (_Event.Type != CSmModeEvent::EType::OnNearMiss) return "";						// Wrong event type
	if (_Event.MissDist <= 0. || _Event.MissDist > C_MissMessageMaxDist) return "";		// Invalid miss distance
	if (_Event.Victim == Null) return "";												// Invalid victim
	
	// Get message text
	declare Message = "";
	declare Dist = MathLib::NearestInteger(_Event.MissDist * 1000.);
	if (Dist >= 10.) {
		Message = (Dist / 10.)^"cm!";
	} else {
		Dist = MathLib::NearestInteger(_Event.MissDist * 10000.);
		if (Dist >= 10.) {
			Message = (Dist / 10.)^"mm!";
		} else {
			Dist = MathLib::NearestInteger(_Event.MissDist * 10000000.);
			Message = (Dist / 10.)^"m!";
		}
	}
	return TextLib::Compose(_("You missed %1 by %2"), GetColorizedPlayerName(_Event.Victim), Message);
}

// Get the current rankings for xmlrpc callbacks
Text GetRankings() {
	declare PlayerList = "";
	foreach (Score in Scores) {
		if (Score.User == Null || Score.User.IsFakeUser) continue;
		PlayerList ^= Score.User.Login^":"^Score.Points^";";
	}
	return PlayerList;
}

// Create markers layer manialink
Text CreateMarkersLayer() {
	declare BallImageSize = 0.45;
	declare Manialink = """<script><!--
		#Include "TextLib" as TextLib

		main() {
			wait(InputPlayer != Null);
			
			declare Frame_BallMarkerHelp	<=> (Page.GetFirstChild("Frame_BallMarkerHelp0") as CMlFrame);
			declare Frame_BallMarker		<=> (Page.GetFirstChild("Frame_BallMarker0") as CMlFrame);
			declare Label_BallMarker		<=> (Frame_BallMarker.GetFirstChild("Label_BallMarker") as CMlLabel);
			declare Quad_BallMarker			<=>	(Frame_BallMarker.GetFirstChild("Quad_BallMarker") as CMlQuad);
			
			declare Frame_GaugeMarker1		<=> (Page.GetFirstChild("Frame_GaugeMarker1") as CMlFrame);
			declare Frame_GaugeMarker2		<=> (Page.GetFirstChild("Frame_GaugeMarker2") as CMlFrame);
			declare Label_GaugeMarker1		<=> (Frame_GaugeMarker1.GetFirstChild("Label_GaugeMarker") as CMlLabel);
			declare Label_GaugeMarker2		<=> (Frame_GaugeMarker2.GetFirstChild("Label_GaugeMarker") as CMlLabel);
			
			declare netread Net_BallCarrierClan		for Teams[0] = Integer[Integer];
			declare netread Net_RemainingDropTime	for Teams[0] = Integer[Integer];
			
			declare LastUIUpdate = -1;
			declare LastUIUpdate2 = -1;
			declare Ident[Integer] GaugeLandmarkIds;

			while (True) {
				yield;
				
				if (LastUIUpdate + 200 > Now) continue;
				LastUIUpdate = Now;
				
				declare CurrentPlayer <=> InputPlayer;
				if (GUIPlayer != Null) CurrentPlayer <=> GUIPlayer;
				
				declare UpdateGauges = False;
				if (GaugeLandmarkIds.count <= 0) {
					UpdateGauges = True;
				} else {
					foreach (GaugeLandmarkId in GaugeLandmarkIds) {
						if (!MapLandmarks_Gauge.existskey(GaugeLandmarkId)) {
							UpdateGauges = True;
							break;
						}
					}
				}
				if (UpdateGauges) {
					GaugeLandmarkIds.clear();
					foreach (GaugeLandmark in MapLandmarks_Gauge) {
						if (GaugeLandmark.Tag != "Goal") continue;
						if (GaugeLandmark.Order == 1 || GaugeLandmark.Order == 2) {
							GaugeLandmarkIds[GaugeLandmark.Order] = GaugeLandmark.Id;
						}
					}
				}
				
				// Update ball marker
				Quad_BallMarker.Visible = IsSpectatorMode || !Net_BallCarrierClan.existskey(0)
					|| Teams.existskey(Net_BallCarrierClan[0] - 1) || !Frame_BallMarkerHelp.Visible;
				
				if (Net_BallCarrierClan.existskey(0) && Teams.existskey(Net_BallCarrierClan[0] - 1)) {
					// Team color
					Quad_BallMarker.Colorize = Teams[Net_BallCarrierClan[0] - 1].ColorPrimary;
				} else {
					// White neutral color
					Quad_BallMarker.Colorize = <1., 1., 1.>;
				}
				
				// Show remaining drop time
				if (Net_BallCarrierClan.existskey(0) && Net_BallCarrierClan[0] == 0
					&& Net_RemainingDropTime.existskey(0) && Net_RemainingDropTime[0] > 0) {
					Label_BallMarker.Value = TextLib::ToText((Net_RemainingDropTime[0] + 300) / 1000);
				} else {
					Label_BallMarker.Value = "";
				}
				
				if (LastUIUpdate2 + 4000 > Now) continue;
				LastUIUpdate2 = Now;
				
				// Update gauge markers
				foreach (Order => GaugeLandmarkId in GaugeLandmarkIds) {
					declare GaugeLandmark <=> MapLandmarks_Gauge[GaugeLandmarkId];
					
					declare TextValue = "";
					declare GaugeClan = GaugeLandmark.Gauge.Clan;
					if (Teams.existskey(GaugeClan - 1)) {
						if (IsSpectatorMode) {
							TextValue = TextLib::Compose("%1%2 %3", Teams[GaugeClan - 1].ColorizedName, Teams[GaugeClan - 1].ColorText, _("Attack"));
						} else {
							declare Action = _("Defend");
							if (GaugeLandmark.Gauge.Clan == CurrentPlayer.CurrentClan) {
								Action = _("Attack");
							}
							TextValue = TextLib::Compose("%1%2", Teams[GaugeClan - 1].ColorText, Action);
						}
					}
					switch (Order) {
						case 1: {
							Label_GaugeMarker1.Value = TextValue;
						}
						case 2: {
							Label_GaugeMarker2.Value = TextValue;
						}
					}
				}
			}
		}
		--></script>
		<frame id="Frame_BallMarkerHelp0" hidden="1"/>
		<frame id="Frame_BallMarker0" hidden="1">
			<label id="Label_BallMarker" sizen="9 16" posn="0.1 5.5" scale="0.9" textprefix="$f05" halign="center" valign="bottom"/>
			<quad id="Quad_BallMarker" sizen="{{{9. * BallImageSize}}} {{{16. * BallImageSize}}}" image="file://Media/Images/SpeedBall/BallLogo.png"
				opacity="0.9" halign="center" valign="bottom"/>
		</frame>
		<framemodel id="Model_GaugeMarkerFrame">
			<label id="Label_GaugeMarker" posn="0 4 -39" textsize="2" scale="0.8" halign="center" valign="center2"/>
			<quad posn="0 4 -40" sizen="16 4" style="BgsPlayerCard" substyle="BgMediaTracker" halign="center" valign="center2"/>
			<quad posn="0 2 -40" sizen="4 8.5" opacity="0.4" halign="center" valign="center2" colorize="1 1 1" image="{{{C_ImgBaseDir}}}target.dds"/>
		</framemodel>
		<frameinstance id="Frame_GaugeMarker1" modelid="Model_GaugeMarkerFrame" hidden="1"/>
		<frameinstance id="Frame_GaugeMarker2" modelid="Model_GaugeMarkerFrame" hidden="1"/>""";
	return Manialink;
}

// Check for changes of the script settings
Void CheckSettings() {
	declare UpdateRules = False;
	declare UpdateFooter = False;
	
	// Check throwable ball setting
	declare Last_ThrowableBall for This = S_ThrowableBall;
	if (Last_ThrowableBall != S_ThrowableBall) {
		Last_ThrowableBall = S_ThrowableBall;
		foreach (BallObjectId in G_BallObjectsIds) {
			if (!Objects.existskey(BallObjectId)) continue;
			declare BallObject <=> Objects[BallObjectId];
			BallObject.Throwable = S_ThrowableBall;
		}
		if (S_ThrowableBall) {
			UIManager.UIAll.SendChat("The $<$0f0Ball$> is now $<$f80throwable$>!");
		} else {
			UIManager.UIAll.SendChat("The $<$0f0Ball$> is $<$f80not$> throwable anymore!");
		}
	}
	
	// Check friendly fire setting
	declare Last_FriendlyFire for This = S_FriendlyFire;
	if (Last_FriendlyFire != S_FriendlyFire) {
		if (S_FriendlyFire) {
			UIManager.UIAll.SendChat("$<$f80Friendly Fire$> is now $<$0f0activated$>!");
		} else {
			UIManager.UIAll.SendChat("$<$f80Friendly Fire$> is now $<$f11deactivated$>!");
		}
		Last_FriendlyFire = S_FriendlyFire;
		UpdateRules = True;
	}
	
	// Check gameplay mode setting
	declare Last_Mode for This = S_Mode;
	if (Last_Mode != S_Mode) {
		switch (S_Mode) {
			case 1: {
				UIManager.UIAll.SendChat("$<$f80Laser Mode$> is now $<$0f0activated$>!");
			}
			case 2: {
				UIManager.UIAll.SendChat("$<$f80Random Mode$> is now $<$0f0activated$>!");
			}
			default: {
				UIManager.UIAll.SendChat("$<$f80Normal Mode$> is now $<$0f0activated$>!");
			}
		}
		Last_Mode = S_Mode;
		UpdateRules = True;
	}
	
	// Check rounds to win setting
	declare Last_RoundsToWin for This = S_RoundsToWin;
	if (Last_RoundsToWin != S_RoundsToWin) {
		Last_RoundsToWin = S_RoundsToWin;
		UpdateFooter = True;
	}
	
	// Check rounds limit setting
	declare Last_RoundsLimit for This = S_RoundsLimit;
	if (Last_RoundsLimit != S_RoundsLimit) {
		Last_RoundsLimit = S_RoundsLimit;
		UpdateFooter = True;
	}
	
	// Reset clan map scores?
	declare Last_BestOfXMaps for This = S_BestOfXMatch;
	if (Last_BestOfXMaps != S_BestOfXMatch) {
		if (Last_BestOfXMaps <= 0 && S_BestOfXMatch > 0) {
			G_ClanMapScores = [1 => 0, 2 => 0];
		}
		Last_BestOfXMaps = S_BestOfXMatch;
	}
	
	// Check number of bots
	declare Last_NbBotsBlue for This = S_NbBotsBlue;
	declare Last_NbBotsRed for This = S_NbBotsRed;
	if (Last_NbBotsBlue != S_NbBotsBlue || Last_NbBotsRed != S_NbBotsRed) {
		Last_NbBotsBlue = S_NbBotsBlue;
		Last_NbBotsRed = S_NbBotsRed;
		Bots::SetNbBots(S_NbBotsBlue, S_NbBotsRed);
	}
	
	// Check bot power setting
	declare Last_BotPower for This = S_BotPower;
	if (Last_BotPower != S_BotPower) {
		Last_BotPower = S_BotPower;
		Bots::SetPower(S_BotPower);
	}
	
	// Update rules or footer?
	if (UpdateRules) {
		---Rules---
	}
	if (UpdateFooter) {
//bye
		foreach (Player in Players) {
//			ScoresTable::SetFooterStats(Player, TextLib::Compose(_("Rounds to win: %1 (Limit: %2)"),
//				TextLib::ToText(Last_RoundsToWin), TextLib::ToText(Last_RoundsLimit)));
		}
	}
}

// Perform warm up session
Void DoWarmup() {
	if (MB_UseScriptCallbacks) XmlRpc.SendCallback("BeginWarmup", "");
	
	declare PlayerCount = Players.count;
	declare SlotNb = PlayerCount / 2;
	SlotNb += (PlayerCount % 2);
	if (SlotNb > 6) {
		SlotNb = 6;
	} else if (SlotNb < 3) {
		SlotNb = 3;
	}
	WarmUp2::SetSlotsNb(C_Clan1, SlotNb);
	WarmUp2::SetSlotsNb(C_Clan2, SlotNb);
	
	WarmUp2::Begin();
	foreach (Player in Players) {
		switch (Player.RequestedClan) {
			case 1: {
				WarmUp2::SetPlayerGroup(Player, C_Clan1);
			}
			case 2: {
				WarmUp2::SetPlayerGroup(Player, C_Clan2);
			}
		}
	}
	WarmUp2::Fill();
	
	UIManager.UIAll.BigMessage = TextLib::Compose("$f90%1", _("Warm up"));
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	StartTime = Now + 1000;
	EndTime = -1;
	declare StopWarmUp = False;
	
	while (!WarmUp2::Stop() && !StopWarmUp && (EndTime <= 0 || Now < EndTime) && !MatchEndRequested && !ServerShutdownRequested
		&& !MB_StopServer && !MB_StopMatch && !MB_StopMap) {
		MB_Yield();
		WarmUp2::Loop();
		WarmUp2::ManageEvents();
		
		foreach (Player in Players) {
			switch (Player.SpawnStatus) {
				case CSmPlayer::ESpawnStatus::NotSpawned: {
					declare Spawn <=> MapLandmarks_PlayerSpawn[MathLib::Rand(0, MapLandmarks_PlayerSpawn.count - 1)].PlayerSpawn;
					SM::SpawnPlayer(Player, Player.RequestedClan, Spawn);
					switch (Player.RequestedClan) {
						case 1: {
							WarmUp2::SetPlayerGroup(Player, C_Clan1);
						}
						case 2: {
							WarmUp2::SetPlayerGroup(Player, C_Clan2);
						}
					}
				}
				case CSmPlayer::ESpawnStatus::Spawned: {
					if (Player.RequestsSpectate || Player.RequestedClan != Player.CurrentClan) {
						UnspawnPlayer(Player);
					}
				}
			}
		}
		
		foreach (Event in XmlRpc.PendingEvents) {
			switch (Event.Param1) {
				case "WarmUp_Stop": {
					StopWarmUp = True;
				}
				case "WarmUp_Extend": {
					declare ExtendTime = TextLib::ToInteger(Event.Param2);
					if (ExtendTime > 0 && EndTime > 0) {
						EndTime += ExtendTime;
					}
				}
			}
		}
		
		declare PlayersNbClan1 = WarmUp2::GetPlayersNb(C_Clan1);
		declare PlayersNbClan2 = WarmUp2::GetPlayersNb(C_Clan2);
		declare ReadyPlayersClan1 = WarmUp2::GetReadyPlayersNb(C_Clan1);
		declare ReadyPlayersClan2 = WarmUp2::GetReadyPlayersNb(C_Clan2);
		
		if (ReadyPlayersClan1 > 0 && (ReadyPlayersClan1 >= WarmUp2::GetSlotsNb(C_Clan1) - 1 || ReadyPlayersClan1 >= PlayersNbClan1)
			&& ReadyPlayersClan2 > 0 && (ReadyPlayersClan2 >= WarmUp2::GetSlotsNb(C_Clan2) - 1 || ReadyPlayersClan2 >= PlayersNbClan2)) {
			if (EndTime <= 0) {
				EndTime = Now + S_WarmUpDuration * 1000;
			}
		} else {
			EndTime = -1;
		}
	}
	WarmUp2::End();
	
	StartTime = -1;
	EndTime = -1;
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
	
	if (MB_UseScriptCallbacks) XmlRpc.SendCallback("EndWarmup", "");
	
	MB_Sleep(1000);
}

// Remove the marker of the given player user
Void RemoveMarker(CUser _User) {
	Markers::Minimap_Remove(_User.Login);
}
