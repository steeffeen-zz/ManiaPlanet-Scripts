/* -------------------- */
//	1337 Game Mode		//
//	(Custom Elite)		//
//	Made by steeffeen	//
/* -------------------- */

/* TODO:
- won attack rounds
- UI TAB geht generell net ausblenden wenn man spectator is
- one havent played 3 rounds not attack, another 2 times in row attack
*/

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const	CompatibleMapTypes	"EliteArena"
#Const	Version				"0.4 (2013-02-19)"
#Const	Description			"Practice your Elite skills"

/* INCLUDES */
#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/ShootMania/Rules.Script.txt" as Rules
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/WarmUpSimple.Script.txt" as WarmUp

/* SETTINGS */
// Round settings
#Setting	S_PointsLimit			75		as _("Points limit to win a map")
#Setting	S_TimeLimit				45		as _("Time limit per round (seconds)")
#Setting	S_TimeLimitCapturing	15		as _("Time limit to capture the goal (seconds)")
// Gameplay settings
#Setting	S_CaptureTime			1.5		as _("Time needed to capture goals (seconds)")
#Setting	S_LaserAttackers		True	as _("Attackers get lasers")
#Setting	S_FriendlyFire			False	as _("Friendly Fire (Damage team mates)")
#Setting	S_Beta2Gameplay			True	as _("Use Beta2 Gameplay")
#Setting	S_MaxDefenderCount		3		as _("Maximal count of defenders")
// WarmUp settings
#Setting	S_ForceWarmUp			True	as _("Force warming up before each map")

/* CONSTANTS */
#Const	C_LogEnabled				False		// Enable/disable logging
// UI constants
#Const	C_UITickInterval			250			// Interval of UI refreshes
#Const	C_NearMissDist				1.0			// Max distance to show the near-miss message
#Const	C_HideLayersAtMapEnd		True		// Hides custom layers at map end
#Const	C_TeamsLayerAtTop			False		// Shows playerlist (if enabled) at the top of the screen
// Gameplay constants
#Const	C_AttackerClan				0			// 1: Blue, 2: Red, else random
#Const	C_AttackerAmmoGain			1.0			// Attacker ammunition gain rate
#Const	C_DefenderAmmoGain			1.0			// Defender ammunition gain rate
#Const	C_UseLaserVsBullets			True		// Whether lasers can destroy rockets
#Const	C_AttackRoundBonus			6			// Bonus points for a won attack round
#Const	C_DefendRoundBonus			3			// Bonus points for each alive defending player if they win the round
#Const	C_ExtraTimePerDefender		5			// Extra time in seconds for each additional defender (>3)
// Bot count
#Const	C_NbBots					0			// Number of bots

/* GLOBALES */
declare Integer G_LastUIUpdate;					// Time of last UI update
declare Integer G_LastBigMessage;				// Time of last big message
declare Integer G_LastStatusMessage;			// Time of last status message
declare Ident G_AttackerId;						// Id of currently attacking player
declare Integer G_AttackingClan;				// Currently attacking clan
declare Ident[] G_DefendingPlayerIds;			// IDs of currently defending players
declare Boolean G_CapturingPossible;			// Whether it's possible to capture the goal
declare Integer G_CountdownEndTime;				// Countdown end time
declare Integer[Ident] G_AttackRounds;			// Attack rounds per player
declare Integer[Ident] G_DefendRounds;			// Defend rounds per player
declare Integer G_MaxDefenderCount;				// Maximal count of defenders
declare CUILayer G_LayerScoresTableExtension;	// Layer for ScoresTableExtension
// Setting caches
declare Integer Cache_S_PointsLimit;

/*****************************************************
	EXTENSIONS
*****************************************************/
***StartServer***
***
log("1337.Script.txt loaded!");
log("Version: "^Version);

MB_UseLogging = C_LogEnabled;

// Game settings
UseClans = True;
UseForcedClans = True;
UseLaserVsBullets = C_UseLaserVsBullets;

// Init variables
MB_UseSectionRound = True;

// Rules
declare ModeName = "1337";
declare ModeRules = "$<$1f1Elite$> game mode for $<$4f4training$> matches.";
Rules::Create(ModeName, ModeRules);

// Teams layer
declare LayerTeams <=> UIManager.UILayerCreate();
LayerTeams.AttachId = "LayerTeams";
if (C_TeamsLayerAtTop) {
	LayerTeams.ManialinkPage = """
		<playerlist posn="-107 90" halign="left" valign="top" style="" substyle="Small" lines="5" columns="2" team="1" status="Playing"/>
		<playerlist posn="107 90" halign="right" valign="top" style="" substyle="Small" lines="5" columns="2" team="2" status="Playing"/>""";
} else {
	Interface::SetLayerTeams(LayerTeams);
}
// Position layer
declare LayerPosition <=> UIManager.UILayerCreate();
LayerPosition.AttachId = "LayerPosition";
Interface::SetLayerPosition(LayerPosition);
// Scores table extension
G_LayerScoresTableExtension <=> UIManager.UILayerCreate();
G_LayerScoresTableExtension.AttachId = "LayerScoreBoardExtension";
G_LayerScoresTableExtension.Type = CUILayer::EUILayerType::ScoresTable;
// Match information
declare LayerInformation <=> UIManager.UILayerCreate();
LayerInformation.AttachId = "LayerInformation";
LayerInformation.ManialinkPage = GetLayerInformation();
***

***StartMap***
***
XmlRpc.SendCallback("beginMap", "");

Mode::Ladder_OpenMatch_All();

// UI
UIManager.ResetAll();
UIManager.UIAll.NoticesFilter_HideMapWarning = True;
SM::SetupDefaultVisibility();
// Layers
LayerTeams.IsVisible = True;
UIManager.UIAll.UILayers.add(LayerTeams);
UIManager.UIAll.UILayers.add(G_LayerScoresTableExtension);
UIManager.UIAll.UILayers.add(LayerInformation);
Rules::Attach();

// Prepare match
Score::MatchBegin();
Victory::MatchBegin();
SetNbFakePlayers(C_NbBots, 0);

// Initialize values
G_LastUIUpdate = 0;
G_LastBigMessage = 0;
G_LastStatusMessage = 0;
G_AttackingClan = 0;
G_AttackRounds.clear();
G_DefendRounds.clear();

// Prepare map
foreach (Base in Bases) {
	Base.IsActive = True;
	Base.Clan = 0;
}

// WarmUp
if (S_ForceWarmUp || PlayersNbTotal < 2) {
	UseClans = False;
	WarmUp::Initialize(0);
	WarmUp::SetMinimumPlayersNumber(1);
	WarmUp::Start();
}
***

***StartRound***
***
XmlRpc.SendCallback("beginRound", GetRankings());

// UI
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;

SM::UnspawnAllPlayers();
Score::RoundBegin();
Victory::RoundBegin();
SetNbFakePlayers(C_NbBots, 0);

// WarmUp check
if (PlayersNbTotal < 2) {
	UseClans = False;
	WarmUp::Initialize(0);
	WarmUp::SetMinimumPlayersNumber(2);
	WarmUp::Start();
}

// Initialize values
PrepareNextRound();

// Announce attacking player
if (Players.existskey(G_AttackerId)) {
	UIManager.UIAll.BigMessage = """$<{{{Players[G_AttackerId].Name}}}$> is attacking!""";
	G_LastBigMessage = Now;
	UIManager.UIAll.SendNotice(
		"",
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::StartRound, 0);
}

MB_Sleep(1000);

// Set round times
StartTime = Now + 2500;
declare TimeLimit = S_TimeLimit;
if (G_DefendingPlayerIds.count > 3) {
	TimeLimit += (G_DefendingPlayerIds.count - 3) * C_ExtraTimePerDefender;
}
G_CountdownEndTime = StartTime + TimeLimit * 1000;
UIManager.UIAll.CountdownEndTime = G_CountdownEndTime;
EndTime = G_CountdownEndTime + S_TimeLimitCapturing * 1000;

UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
***

***OnNewPlayer***
***
// Prepare UI for the new player
declare UI <=> UIManager.GetUI(Player);
if (UI != Null) {
	UI.UILayers.clear();
	UI.UILayers.add(LayerPosition);
	
	InitPlayer(Player);
}
***

***OnNewSpectator***
***
// Prepare UI for the new spectator
declare UI <=> UIManager.GetUI(Spectator);
if (UI != Null) {
	UI.UILayers.clear();
	
	// Spectating
	UI.SpectatorForcedClan = -1;
}
***

***PlayLoop***
***
// Update settings
CheckScriptSettings();

// Perform actions for each player
foreach (Player in Players) {
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			// Player not spawned -> Spawn him!
			if (!Player.RequestsSpectate && Now < StartTime) {
				MySpawnPlayer(Player);
			}
		}
	}
}

// Check for captures
foreach (Pole in BlockPoles) {
	declare Speed = 0;
	if (G_CapturingPossible) {
		foreach (PlayerId in Pole.Sector.PlayersIds) {
			if (Players.existskey(PlayerId) && Players[PlayerId].CurrentClan == G_AttackingClan) {
				Speed += 1;
			}
		}
	}
	Pole.Gauge.Speed = Speed;
}

// Handle pending events
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnHit: {
			if (Event.Shooter == Null || Event.Victim == Null) {
				// Discard buggy event
				Discard(Event);
			} else {
				if (Event.Shooter == Event.Victim) {
					// Discard self damage
					Discard(Event);
				} else {
					if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
						if (S_FriendlyFire) {
							// PassOn team hits
							declare Points = -2;
							Event.ShooterPoints = Points;
							Score::AddPoints(Event.Shooter, Points);
							PassOn(Event);
						} else {
							// Discard team hits
							Discard(Event);
						}
					} else {
						Event.Damage = 100;
						// Grant points for the hit
						declare Points = 1;
						Event.ShooterPoints = Points;
						Score::AddPoints(Event.Shooter, Points);
						if (Event.Shooter.Id != G_AttackerId && Event.Victim.Armor >= 200) {
							// Announce left armor count
							declare ArmorLeft = (Event.Victim.Armor-100)/100;
							if (ArmorLeft > 0) {
								UIManager.UIAll.SendNotice(
									"""{{{ArmorLeft}}} armor left!""",
									CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
									CUIConfig::EUISound::TiePoint, 5-ArmorLeft);
							}
						}
						if (!Event.Victim.IsFakePlayer && !Event.Shooter.IsFakePlayer) {
							XmlRpc.SendCallback("playerHit", "Victim:"^Event.Victim.Login^";Shooter:"^Event.Shooter.Login^";1;");
						}
						PassOn(Event);
					}
				}
			}
		}
		case CSmModeEvent::EType::OnArmorEmpty: {
			if (Event.Victim != Null) {
				if (Event.Shooter != Null && Event.Victim.Id != G_AttackerId && ClansNbPlayersAlive[3-G_AttackingClan] >= 2) {
					// Announce shot distance
					declare Distance = MathLib::NearestInteger(10*MathLib::Distance(Event.Shooter.Position, Event.Victim.Position))/10.0;
					UIManager.UIAll.SendNotice(
						"""{{{Distance}}}m hit!""",
						CUIConfig::ENoticeLevel::PlayerInfo, Null, CUIConfig::EAvatarVariant::Default, 
						CUIConfig::EUISound::Silence, 0);
				}
				// Announce left defender count
				declare DefenderLeft = ClansNbPlayersAlive[3-G_AttackingClan]-1;
				if (DefenderLeft > 0) {
					UIManager.UIAll.SendNotice(
						"""{{{DefenderLeft}}} defender left!""",
						CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
						CUIConfig::EUISound::TieBreakPoint, 5-DefenderLeft);
				}
				if (!Event.Victim.IsFakePlayer) {
					if (Event.Shooter == Null) {
						XmlRpc.SendCallback("playerDeath", Event.Victim.Login);
					} else {
						if (!Event.Shooter.IsFakePlayer) {
							XmlRpc.SendCallback("playerKill", "Victim:"^Event.Victim.Login^";Shooter:"^Event.Shooter.Login);
						}
					}
				}
			}
			PassOn(Event);
		}
		case CSmModeEvent::EType::OnCapture: {
			// Goal captured - Attackers win
			Victory::SetRoundWinnerIfNoWinner(G_AttackingClan);
			if (Players.existskey(G_AttackerId) && Event.BlockPole.Sector.PlayersIds.exists(G_AttackerId)) {
				UIManager.UIAll.SendNotice(
					"""$<{{{Players[G_AttackerId].Name}}}$> captured the goal!""",
					CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default, 
					CUIConfig::EUISound::Capture, 0);
				XmlRpc.SendCallback("poleCapture", Players[G_AttackerId].Login);
				PassOn(Event);
			} else {
				Event.BlockPole.Gauge.ValueReal = 0.999;
				Discard(Event);
			}
		}
		case CSmModeEvent::EType::OnNearMiss: {
			// Near miss
			if (C_NearMissDist >= 0 && Event.MissDist <= C_NearMissDist) {
				UIManager.UIAll.StatusMessage = GetNearMissMessage(Event);
				G_LastStatusMessage = Now;
			}
			PassOn(Event);
		}
		default: {
			PassOn(Event);
		}
	}
}

// UI
if (G_LastUIUpdate + C_UITickInterval < Now) {
	G_LastUIUpdate = Now;
	
	// Clear big message
	if (G_LastBigMessage != 0 && G_LastBigMessage + 4000 < Now) {
		G_LastBigMessage = 0;
		UIManager.UIAll.BigMessage = "";
	}
	
	// Clear big message
	if (G_LastStatusMessage != 0 && G_LastStatusMessage + 4000 < Now) {
		G_LastStatusMessage = 0;
		UIManager.UIAll.StatusMessage = "";
	}
	
	// Player UI
	foreach (Player in Players) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null) {
			// Position layer
			UpdateLayerPosition(Player);
			
			// Information 
			UpdateLayerInformation(UI);
	
			// Spectating
			UI.SpectatorForcedClan = Player.CurrentClan;
			
			// Status message
			declare LastStatusMessage for Player = -1;
			if (LastStatusMessage != -1 && LastStatusMessage >= G_LastStatusMessage && LastStatusMessage + 4000 < Now) {
				UI.StatusMessage = "";
				LastStatusMessage = -1;
			}
		}
	}
}

// Activate goal
if (Now >= G_CountdownEndTime) {
	if (!G_CapturingPossible) {
		G_CapturingPossible = True;
		UIManager.UIAll.CountdownEndTime = -1;
		UIManager.UIAll.SendNotice(
			"", CUIConfig::ENoticeLevel::MatchInfo,
			Null, CUIConfig::EAvatarVariant::Default,
			CUIConfig::EUISound::PhaseChange, 0);
	}
	if (UIManager.UIAll.StatusMessage == "") {
		UIManager.UIAll.StatusMessage = "The goal can now be captured!";
	}
}

// Clear counts arrays
foreach (PlayerId => Rounds in G_AttackRounds) {
	if (!Players.existskey(PlayerId) && !Spectators.existskey(PlayerId)) {
		declare Temp = G_AttackRounds.removekey(PlayerId);
	}
}
foreach (PlayerId => Rounds in G_DefendRounds) {
	if (!Players.existskey(PlayerId) && !Spectators.existskey(PlayerId)) {
		declare Temp = G_DefendRounds.removekey(PlayerId);
	}
}

// Check round end conditions
if (Now >= EndTime) {
	// Time is up - Defenders win
	Victory::SetRoundWinnerIfNoWinner(3-G_AttackingClan);
} else {
	if (ClansNbPlayersAlive[G_AttackingClan] <= 0) {
		// Attacker eliminated
		Victory::SetRoundWinnerIfNoWinner(3-G_AttackingClan);
	} else {
		if (ClansNbPlayersAlive[3-G_AttackingClan] <= 0) {
			// Defender eliminated
			Victory::SetRoundWinnerIfNoWinner(G_AttackingClan);
		}
	}
}
if (!MB_StopRound && !Victory::NoRoundWinner()) {
	// Round winner found
	MB_StopRound = True;
}
***

***EndRound***
***
XmlRpc.SendCallback("endRound", GetRankings());

EndTime = Now;
foreach (Pole in BlockPoles) {
	Pole.Gauge.Speed = 0;
}
UIManager.UIAll.StatusMessage = "";
MB_Sleep(1000);

// Evaluate round
declare Message = "Round Draw";
if (Victory::IsRoundWinner(G_AttackingClan) && Players.existskey(G_AttackerId)) {
	Message = """$<{{{Players[G_AttackerId].Name}}}$> wins the round!""";
	if (Players.existskey(G_AttackerId) && !Players[G_AttackerId].IsFakePlayer) {
		XmlRpc.SendCallback("attackerWon", Players[G_AttackerId].Login);
	}
	if (Players[G_AttackerId].Score != Null) {
		Score::AddPoints(Players[G_AttackerId], C_AttackRoundBonus);
	}
} else {
	Message = """$<{{{Teams[2-G_AttackingClan].ColorText}}}Defenders$> win the round!""";
	foreach (DefenderId in G_DefendingPlayerIds) {
		if (Players.existskey(DefenderId) && Players[DefenderId].Armor > 0) {
			Score::AddPoints(Players[DefenderId], C_DefendRoundBonus);
			if (!Players[DefenderId].IsFakePlayer) {
				XmlRpc.SendCallback("playerSurvival", Players[DefenderId].Login);
			}
		}
	}
	
}
UIManager.UIAll.BigMessage = Message;
G_LastBigMessage = Now;

MB_Sleep(1500);

SM::UnspawnAllPlayers();
UIManager.UIAll.CountdownEndTime = -1;

UseClans = False;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

MB_Sleep(2000);

Score::RoundEnd();
Victory::RoundEnd();

// Check match end conditions
foreach (Score in Scores) {
	if (Score.Points >= S_PointsLimit) {
		// Match winner found
		MB_StopMap = True;
		break;
	}
}
***

***EndMap***
***
XmlRpc.SendCallback("endMap", GetRankings());

Score::MatchEnd();
Victory::MatchEnd();

// UI
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
if (C_HideLayersAtMapEnd) {
	LayerTeams.IsVisible = False;
}

// Announce victorious clan
declare Message = "Match Draw";
declare CUser Winner <=> Null;
declare MaxPoints = 0;
foreach (Score in Scores) {
	if (Score.Points > MaxPoints) {
		MaxPoints = Score.Points;
		Winner <=> Score.User;
	}
}
if (Winner != Null) {
	Message = """$<{{{Winner.Name}}}$> wins the map!""";
}
UIManager.UIAll.BigMessage = Message;
G_LastBigMessage = Now;

MB_Sleep(3000);

Mode::Ladder_CloseMatch();
***

***EndServer***
***

// UI Cleanup
UIManager.UILayerDestroy(LayerTeams);
***

/*****************************************************
	FUNCTIONS
*****************************************************/

// Spawn player
Void MySpawnPlayer(CSmPlayer _Player) {
	if (C_LogEnabled) MB_Log("MySpawnPlayer("^_Player.Login);
	
	if (Now < StartTime && !_Player.RequestsSpectate) {
		// Get spawn
		declare SpawnId = NullId;
		foreach (Spawn in BlockSpawns) {
			if (_Player.Id == G_AttackerId && Spawn.Base.Clan == G_AttackingClan) {
				SpawnId = Spawn.Id;
				break;
			} else {
				if (_Player.Id != G_AttackerId && G_DefendingPlayerIds.exists(_Player.Id) && Spawn.Base.Clan != G_AttackingClan) {
					SpawnId = Spawn.Id;
					break;
				}
			}
		}
		
		// Set values depending on player clan
		if (SpawnId != NullId) {
			if (_Player.Id == G_AttackerId) {
				// Attacker
				if (S_LaserAttackers) {
					This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Laser, False);
				} else {
					This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
				}
				_Player.AmmoGain = C_AttackerAmmoGain;
				_Player.ArmorMax = G_DefendingPlayerIds.count * 100;
				
				// Spawn player
				SM::SpawnPlayer(_Player, G_AttackingClan, BlockSpawns[SpawnId], StartTime);
			} else {
				// Defender
				This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
				_Player.AmmoGain = C_DefenderAmmoGain;
				_Player.ArmorMax = 100;
				
				// Spawn player
				SM::SpawnPlayer(_Player, 3-G_AttackingClan, BlockSpawns[SpawnId], StartTime);
				
				declare UI <=> UIManager.GetUI(_Player);
				if (UI != Null) {
					UI.StatusMessage = Teams[2-G_AttackingClan].ColorText^"You are defending!";
					declare LastStatusMessage for _Player = -1;
					LastStatusMessage = Now;
				}
			}
		}
	}
}

Integer GetHighestValue(Integer[Ident] _RoundsArray) {
	declare HighestValue = 0;
	foreach (Id => Value in _RoundsArray) {
		if (Value > HighestValue) {
			HighestValue = Value;
		}
	}
	return HighestValue;
}

// Init player
Void InitPlayer(CSmPlayer _Player, Boolean _Forced) {
	// Init atk/def values
	if (_Forced) {
		// Full init
		G_AttackRounds[_Player.Id] = 0;
		G_DefendRounds[_Player.Id] = 0;
		declare LastAttackTime for _Player = 0;
		LastAttackTime = Now;
		declare LastDefendTime for _Player = 0;
		LastDefendTime = Now;
	} else {
		// Only init if necessary
		if (!G_AttackRounds.existskey(_Player.Id)) {
			G_AttackRounds[_Player.Id] = GetHighestValue(G_AttackRounds);
		}
		if (!G_DefendRounds.existskey(_Player.Id)) {
			G_DefendRounds[_Player.Id] = GetHighestValue(G_DefendRounds);
		}
	}
}

Void InitPlayer(CSmPlayer _Player) {
	InitPlayer(_Player, False);
}

// Generates manialink for ScoresTableExtension layer
Text GetScoresTableExtensionLayer() {
	return """
		<frame posn="0 -49.1">
			<quad sizen="30 5" halign="center" valign="center" bgcolor="0006"/>
			<label scale="0.7" halign="center" valign="center" text="$bbbPoints Limit: {{{S_PointsLimit}}}"/>
		</frame>""";
}

// Checks for changed script settings and performs updates
Void CheckScriptSettings() {
	// Check max defender count
	if (S_MaxDefenderCount <= 0) {
		G_MaxDefenderCount = 3;
	} else {
		G_MaxDefenderCount = S_MaxDefenderCount;
	}
	
	// Update gameplay version
	if (S_Beta2Gameplay && GameplayVersion != 1) {
		GameplayVersion = 1;
	} else {
		if (!S_Beta2Gameplay && GameplayVersion != 0) {
			GameplayVersion = 0;
		}
	}
	
	// Update points limit
	if (Cache_S_PointsLimit != S_PointsLimit) {
		Cache_S_PointsLimit = S_PointsLimit;
		G_LayerScoresTableExtension.ManialinkPage = GetScoresTableExtensionLayer();
	}
}

// Check if clublink defined team names
Boolean TeamsHaveClublinkNames() {
	for (Index, 0, 1) {
		switch (Teams[Index].Name) {
			case "Blue": {}
			case "Red": {}
			case "Attacker": {}
			case "Defenders": {}
			default: {
				return True;
			}
		}
	}
	return False;
}

// Change sides and stuff
Void PrepareNextRound() {
	if (C_LogEnabled) MB_Log("PrepareNextRound");
	
	CheckScriptSettings();
	SM::UnspawnAllPlayers();
	G_CapturingPossible = False;
	G_AttackerId = NullId;
	UseClans = True;
	
	// Get attacking clan
	if (C_AttackerClan != 1 && C_AttackerClan != 2) {
		G_AttackingClan = MathLib::Rand(1,2);
	} else {
		G_AttackingClan = C_AttackerClan;
	}
	// Set team names
	if (!TeamsHaveClublinkNames()) {
		Teams[G_AttackingClan-1].Name = "Attacker";
		Teams[2-G_AttackingClan].Name = "Defenders";
	}
	
	// Assign spawns
	foreach (Spawn in BlockSpawns) {
		switch (Spawn.Tag) {
			case "SpawnAttack": {
				Spawn.Base.Clan = G_AttackingClan;
			}
			case "SpawnDefense": {
				Spawn.Base.Clan = 3-G_AttackingClan;
			}
		}
	}
	// Assign poles
	foreach (Pole in BlockPoles) {
		Pole.Gauge.Max = MathLib::NearestInteger(S_CaptureTime * 1000);
		Pole.Gauge.ValueReal = 0.0;
		
		Pole.Base.Clan = G_AttackingClan;
		Pole.Gauge.Clan = G_AttackingClan;
	}
	
	// Get attack player
	declare FewestAttackRounds = -1;
	
	foreach (Player in Players) {
		if (!Player.RequestsSpectate) {
			InitPlayer(Player);
			if (G_AttackRounds[Player.Id] < FewestAttackRounds || FewestAttackRounds < 0) {
				G_AttackerId = Player.Id;
				FewestAttackRounds = G_AttackRounds[Player.Id];
			}
		}
	}
	
	// Get defending players
	declare Ident[Integer] FewestDefendRoundPlayerIds;
	G_DefendingPlayerIds = Ident[];
	
	foreach (Player in Players) {
		if (Player.Id != G_AttackerId && !Player.RequestsSpectate) {
			// Fill empty defender spots
			for (Index, 1, G_MaxDefenderCount) {
				if (!FewestDefendRoundPlayerIds.existskey(Index)) {
					FewestDefendRoundPlayerIds[Index] = Player.Id;
					break;
				}
			}
			if (!Player.IsFakePlayer) {
				// Replace players who have played more often
				if (!FewestDefendRoundPlayerIds.exists(Player.Id)) {
					foreach (Index => PlayerId in FewestDefendRoundPlayerIds) {
						if (G_DefendRounds[Player.Id] < G_DefendRounds[PlayerId]) {
							FewestDefendRoundPlayerIds[Index] = Player.Id;
							break;
						}
					}
				}
				// Replace bots by players
				if (!FewestDefendRoundPlayerIds.exists(Player.Id)) {
					foreach (Index => PlayerId in FewestDefendRoundPlayerIds) {
						if (Players[PlayerId].IsFakePlayer) {
							FewestDefendRoundPlayerIds[Index] = Player.Id;
							break;
						}
					}
				}
			}
		}
	}
	
	foreach (PlayerId in FewestDefendRoundPlayerIds) {
		G_DefendingPlayerIds.add(PlayerId);
	}
	
	// Set players clans
	foreach (Player in Players) {
		if (Player.Id == G_AttackerId) {
			// Attacker
			This.SetPlayerClan(Player, G_AttackingClan);
			G_AttackRounds[Player.Id] += 1;
			declare LastAttackTime for Player = 0;
			LastAttackTime = Now;
			
			XmlRpc.SendCallback("playerActive", Player.Login);
		} else {
			if (G_DefendingPlayerIds.exists(Player.Id)) {
				// Defender
				This.SetPlayerClan(Player, 3-G_AttackingClan);
				G_DefendRounds[Player.Id] += 1;
				declare LastDefendTime for Player = 0;
				LastDefendTime = Now;
				
				XmlRpc.SendCallback("playerActive", Player.Login);
			} else {
				// Inactive
				This.SetPlayerClan(Player, 0);
				
				XmlRpc.SendCallback("playerInactive", Player.Login);
			}
		}
	}
}

// Update a player position UI
Void UpdateLayerPosition(CSmPlayer _Player) {
	declare UI <=> UIManager.GetUI(_Player);
	if (UI != Null) {
		declare LibInterface_LastPosCurrent for _Player = -1;
		declare netwrite Integer Net_LibInterface_LayerInfoUpdate for UI;
		declare netwrite Integer Net_LibInterface_PosTotal for UI;
		declare netwrite Integer Net_LibInterface_PosCurrent for UI;
		
		Net_LibInterface_LayerInfoUpdate = Now;
		Net_LibInterface_PosTotal = Scores.count;
		Net_LibInterface_PosCurrent = Scores.keyof(_Player.Score) + 1;
	}
}

// Generates information layer
Text GetLayerInformation() {
	return """
		<script><!--
			main() {
				declare Label_AtkArmor <=> (Page.GetFirstChild("AtkArmor") as CMlLabel);
				declare Gauge_CapGauge <=> (Page.GetFirstChild("CapGauge") as CMlGauge);
				
				declare netread Net_AtkArmor for UI = -1;
				
				declare LastUIUpdate = 0;
				
				while (True) {
					yield;
					
					if (LastUIUpdate + 400 < Now) {
						LastUIUpdate = Now;
						
						// Update attacker armor
						declare LabelText = "";
						if (Net_AtkArmor >= 0) {
							LabelText = "Attacker Armor: "^Net_AtkArmor;
						}
						Label_AtkArmor.SetText(LabelText);
						
						// Capturing gauge
						declare CSmPlayer GaugePlayer <=> Null;
					//	if (GUIPlayer != Null) {
					//		GaugePlayer <=> GUIPlayer;
					//	} else {
							if (InputPlayer != Null) {
								GaugePlayer <=> InputPlayer;
							}
					//	}
						if (GaugePlayer != Null && GaugePlayer.BlockPole != Null) {
							Gauge_CapGauge.Visible = True;
							Gauge_CapGauge.SetRatio(GaugePlayer.BlockPole.Gauge.ValueReal);
							Gauge_CapGauge.SetClan(GaugePlayer.BlockPole.Gauge.Clan);
						} else {
							Gauge_CapGauge.Visible = False;
						}
					}
				}
			}
		--></script>
		<frame>
			<gauge id="CapGauge" posn="0 -35" sizen="110 8" style="EnergyBar" hidden="1" halign="center" valign="center"/>
			<label id="AtkArmor" posn="110 -87" scale="0.7" textcolor="fffa" halign="center" valign="center"/>
		</frame>""";
}

// Updates information layer
Void UpdateLayerInformation(CUIConfig _UI) {
	declare netwrite Net_AtkArmor for _UI = -1;
	if (Players.existskey(G_AttackerId)) {
		Net_AtkArmor = Players[G_AttackerId].Armor / 100;
	} else {
		Net_AtkArmor = -1;
	}
}

// Creates message for near miss
Text GetNearMissMessage(CSmModeEvent _Event) {
	// Catch invalid events
	if (_Event.Type != CSmModeEvent::EType::OnNearMiss) return "";	// Wrong event type
	if (_Event.MissDist <= 0.0) return "";							// Invalid miss distance
	if (_Event.Shooter == Null || _Event.Victim == Null) return "";	// Invalid players
	
	// Get message text
	declare Message = "";
	declare Dist = MathLib::NearestInteger(_Event.MissDist * 1000);
	if (Dist >= 10) {
		Message = (Dist/10.0)^"cm!";
	} else {
		Dist = MathLib::NearestInteger(_Event.MissDist * 10000);
		if (Dist >= 10) {
			Message = (Dist/10.0)^"mm!";
		} else {
			Dist = MathLib::NearestInteger(_Event.MissDist * 10000000);
			Message = (Dist/10.0)^"Âµm!";
		}
	}
	return TextLib::Compose(_("$<%1$> missed $<%2$> by %3"), _Event.Shooter.Name, _Event.Victim.Name, Message);
}

// Get the current rankings for xmlrpc callbacks
Text GetRankings() {
	declare PlayerList = "";
	foreach (Score in Scores) {
		PlayerList ^= Score.User.Login^":"^Score.Points^";";
	}
	return PlayerList;
}
