/* ------------------------------------ */
//	SpeedBall Game Mode					//
//	Original is created by Awpteamoose	//
//	This version is made by steeffeen	//
/* ------------------------------------ */

/*
TODO:
- full clublinks/teams support
- new scoreboard + top lists
*/

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const	CompatibleMapTypes	"SpeedBallArena"
#Const	Version				"1.6.2 (2013-03-24)"

/* INCLUDES */
#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Color.Script.txt" as Color
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Top.Script.txt" as Top
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/ShootMania/Achievements.Script.txt" as Achievements
#Include "Libs/Nadeo/ShootMania/AFK.Script.txt" as AFK
#Include "Libs/Nadeo/ShootMania/BalancedWeapons.Script.txt" as BalancedWeapons
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/Nadeo/ShootMania/WarmUpSimple.Script.txt" as WarmUp

/* SETTINGS */
// Round settings
#Setting	S_TimeLimit			240		as _("Time limit per round (seconds)")
#Setting	S_OvertimeLimit		45		as _("Time limit during Overtime (seconds)")
#Setting	S_RoundsToWin		5		as _("Rounds to win a map")
#Setting	S_RoundGapToWin		2		as _("Rounds gap to win a map")
#Setting	S_RoundsLimit		10		as _("Total rounds limit per map (First team reaching X wins)")
#Setting	S_UseWarmUp			False	as _("Start a warmup before each map")
// Team settings
#Setting	S_AutoTeamBalance	False	as _("Automatically balance teams before each map")
#Setting	S_MaxPlayerCount	0		as _("Maximal count of players (0 = unlimited)")
#Setting	S_NbBotsBlue		0		as _("Number of bots in team Blue")
#Setting	S_NbBotsRed			0		as _("Number of bots in team Red")
#Setting	S_BotPower			2.0		as _("Defines the power of bots (Default: 2.0)")
// Gameplay settings
#Setting	S_FriendlyFire		False	as _("Friendly fire (Damage team members)")
#Setting	S_LaserBattle		False	as _("Laser Battle (Rail gun for every player)")

/* CONSTANTS */
#Const	C_LogEnabled				False		// Enable/disable logging
#Const	C_ManageAFKPlayers			True		// Forces afk players into spec
// Gameplay constants
#Const	C_RespawnTime				3000		// Time until a player is respawned
#Const	C_EndRoundOnDrop			False		// Enabled: Round ends on drop / Disabled: On reset
#Const	C_TimeToDecResetTime1Sec	30			// Time to decrease the reset time by 1 second (in seconds) (-1 to disable)
#Const	C_BallCarrierArmorReplenishGain	200		// Value for the armor regeneration of the ball carrier
#Const	C_UseAlternateBallWeaponVisual	True	// Use alternate weapon visual for ball carrier (white rockets)
#Const	C_BallPickUpDistance		2.1			// Distance to pick up the ball
#Const	C_DroppedBallResetTime		4500		// Time until a dropped ball will reset
#Const	C_NeededCaptureTime			1600		// Time needed for capturing
#Const	C_DecrScoreOnFriendHit		True		// Decrease score on friendly fire hit
#Const	C_ReduceLaserDamage			True		// Enable to reduce the laser damage so that hits do only 1 point damage
#Const	C_NormalExtraAmmoGain		0.0			// Additional ammunition gain when running normal battle
#Const	C_InstaGibExtraAmmoGain		0.4			// Additional ammunition gain when running instagib battle
#Const	C_LongestInstaPassDist		100.0		// Longest possible pass in instagib (0 = no limit, rockets fly up to 150m)
#Const	C_NucleusSelfDamage			False		// Nucleus explosions damage yourself (like a granate)
#Const	C_PlayerHighlightValue		0.6			// How much the players get highlighted (ball carrier -> 1.0)
#Const	C_BotsCanHaveBall			True		// Disable to disallow bots to have the ball
#Const	C_AllowForwardSpawns		True		// Allow forward spawns&goals on maps
#Const	C_ForwardCaptureTime		10000		// Time in milliseconds to fully capture the forward goal
#Const	C_ForwardCapturePercentage	0.75		// Percentage needed to activate the forward goal
// WarmUp constants
#Const	C_WarmUpDuration			90			// WarmUp duration
// UI constants
#Const	C_UITickInterval			250			// Interval of UI refreshes
#Const	C_UseTops					True		// Enable/disable top x rankings
#Const	C_TopCount					5			// Count of players displayed in top rankings
#Const	C_UseNewTopStyle			True		// True: Use new top style (Beta2), False: Use old style
#Const	C_ShowBotsInTops			False		// Enable to show bots in top x rankings
#Const	C_HideStuffAtMapEnd			True		// Enable to hide top rankings & stuff at map end
#Const	C_TeamsLayerAtTop			False		// Shows playerlist (if enabled) at the top of the screen
#Const	C_UseAchievements			True		// Enable/disable achievements (may spam your screen!)
#Const	C_UseTeamsLayer				True		// Enable/disable teams layer (playerlists on the sides)
#Const	C_NbTeamHitMessage			3			// Times the team hit warning appears (0: deactivated, -1: endless)
#Const	C_NearMissDist				1.0			// Max distance (meters) for near miss messages (Range: 0.0-1.0)
// Clublink constants
#Const	C_UsePlayerClublinks		True		// Enable use of player clublinks
#Const	C_NeutralEmblemUrl			""			// Neutral emblem URL

/* TEXTS */
#Const	T_Ball				"Ball"											// Ball text
#Const	T_BallReset			_("Ball has been reset!")						// Ball reset message
#Const	T_Overtime			"Overtime"										// Overtime text
#Const	T_WaitForSpawn		_("Waiting to be spawned...")					// Waiting for spawn message
#Const	T_TeamHitMessage	_("$f81Attention! You shot a team member!")		// Warning when hitting a team member
// Top ranking names
#Const	T_Damage			"Damage"
#Const	T_Captures			"Captures"
#Const	T_Passes			"Passes"
#Const	T_Backstabber		"Backstabber"
// Description
#Const	Description			"""Two teams fight for control of a $<$0f0Ball$> in order to capture the opponents goal post.
Grab the Ball and get it to the enemys goalpost to score."""

/* GLOBALES */
declare Ident G_BallCarrierId;					// IDs of the players who have the ball
declare Integer G_BallDropTime;					// Time when the ball was dropped
declare Integer G_BallArmorRegTime;				// Last time of ball armor regeneration
declare Integer G_LastBallResetSeconds;			// Seconds of the last reset countdown tick
declare Integer G_LastUIUpdate;					// Time when the last UI refresh was performed
declare Integer G_LastBigMessage;				// Time when the last BigMessage was send
declare Integer G_LastStatusMessage;			// Time when the last StatusMessage was send
declare Ident G_BallPoleId;						// Id of the ball pole
declare Ident[Integer] G_ClanSpawnIDs;			// BlockSpawn IDs of each clan
declare Ident[Integer] G_ClanPoleIDs;			// BlockPole IDs of each clan
declare Vec3 G_BallHomePosition;				// Position of the ball spawn
declare Vec3 G_BallDropPosition;				// Actual position of the dropped ball
declare Vec3 G_LastBallPosition;				// Last known position of the ball (To drop the ball if ball carrier left)
declare Boolean G_Overtime;						// Whether overtime is active
declare Integer G_ExtraTimeStart;				// Time when the extra time started
declare Ident[] G_PlayingPlayerIDs;				// IDs of all playing players
declare Ident[] G_SpawnedPlayerIDs;				// IDs of all players that are allowed to spawn
declare Ident[] G_WaitingPlayerIDs;				// IDs of all players waiting to be spawned
declare Integer G_ResetTimeMessageStatus;		// Status of the -decreasing reset time- message
declare Integer G_LastAfkHandling;				// Time of last afk players handling
declare Boolean G_ForwardActive;				// Whether forward spawns&goals are active
declare Integer G_ForwardClan;					// Clan that has owns the forward spawn
declare Ident G_ForwardSpawnId;					// Id of forward spawn
declare Ident G_ForwardGoalId;					// Id of forward goal
// Setting caches
declare Boolean Cache_S_FriendlyFire;			// Cache for S_FriendlyFire
declare Boolean Cache_S_LaserBattle;			// Cache for S_LaserBattle

/*****************************************************
	EXTENSIONS
*****************************************************/
***Rules***
***
// Create rules
declare ModeName = "SpeedBall 2.0";
declare BallText = """$<$6f1Ball$>""";

// Setting dependent rules
declare EndRoundVariant = "$3af";
if (C_EndRoundOnDrop) {
	EndRoundVariant ^= "drop";
} else {
	EndRoundVariant ^= "reset";
}
declare EndRoundVariantExtra = "";
if (!C_EndRoundOnDrop && C_TimeToDecResetTime1Sec > 0) {
	EndRoundVariantExtra ^= """ (while the time to $<$3afreset$> the {{{BallText}}} constantly decreases)""";
}

declare ModeRules = """
- Two teams fight for control of the {{{BallText}}} in order to capture the opponents pole.
- Grab the {{{BallText}}} and get it to the enemys goalpost to score.
- Once you have the {{{BallText}}}, hit a player to $<$3afpass$> the {{{BallText}}}.
- If the {{{BallText}}} carrier dies, the {{{BallText}}} will drop at his position. It can be picked up by any player on any team for $<$f80{{{C_DroppedBallResetTime/1000.0}}}$> seconds before it resets.
- If neither team manages to score after $<$f80{{{S_TimeLimit}}}$> seconds the game continues until the next {{{BallText}}} $<{{{EndRoundVariant}}}$> before $<$f30Overtime$> kicks in$<{{{EndRoundVariantExtra}}}$>.
- You're able to win the round by capturing instantly or holding the {{{BallText}}} for $<$f80{{{S_OvertimeLimit}}}$> seconds during $<$f30Overtime$>.
""";
if (S_FriendlyFire) {
	ModeRules ^= """
- $<$f80Friendly Fire$> is activated! Pay attention to not damage your team mates!""";
}
if (S_LaserBattle) {
	ModeRules ^= """
- $<$f80LaserBattle$> is activated! Players spawn with lasers! (Hits cause still only 1 damage.)""";
}

SpawnScreen::CreateRules(ModeName, ModeRules, False);
***

***InitServer***
***
MB_UseLogging = C_LogEnabled;
***

***StartServer***
***
log("SpeedBall 2.0 loaded!");
log("Version: "^Version);
log("Written by steeffeen. (Original by awpteamoose)");

---Rules---

Color::Load();

// Teams
UseClans = True;

// Clublinks
MB_UsePlayerClublinks = C_UsePlayerClublinks;
MB_NeutralEmblemUrl = C_NeutralEmblemUrl;

// Tops
if (C_UseTops) {
	Top::AddTop(T_Damage, C_TopCount);
	Top::AddTop(T_Captures, C_TopCount);
	Top::AddTop(T_Passes, C_TopCount);
	Top::AddTop(T_Backstabber, C_TopCount);
}

// Init variables
MB_UseSectionRound = True;
G_LastUIUpdate = 0;
G_LastBigMessage = 0;
G_LastStatusMessage = 0;
G_LastAfkHandling = 0;

Mode::Ladder_OpenMatch_All();

// Achievements
if (C_UseAchievements) {
	Achievements::InitSettings([
	//	"HitRocket",
	//	"HitRail",
	//	"HitNucleus",
	//	"PrecisionRocket",
	//	"PrecisionRail",
	//	"PrecisionNucleus",
		"LongestRail",
		"LongestRocket",
		"LongestAirShot",
		"AirStrike",
	//	"HitUntouched",
	//	"ComboHit",
	//	"LongestTime",
	//	"LessHited",
	//	"DistanceTravel",
	//	"TimeNearEnnemies",
	//	"AirTime",
	//	"ArmorReload",
		"HitAfterHited"
	]);
}


// UI layers
declare LayerTeams <=> UIManager.UILayerCreate();
if (C_UseTeamsLayer) {
	if (C_TeamsLayerAtTop) {
		LayerTeams.ManialinkPage = """
			<playerlist posn="-107 90" halign="left" valign="top" style="" substyle="Small" lines="5" columns="2" team="1" status="Playing"/>
			<playerlist posn="107 90" halign="right" valign="top" style="" substyle="Small" lines="5" columns="2" team="2" status="Playing"/>""";
	} else {
		Interface::SetLayerTeams(LayerTeams);
	}
}

declare LayerPosition <=> UIManager.UILayerCreate();
Interface::SetLayerPosition(LayerPosition);

declare LayerBallCarrier <=> UIManager.UILayerCreate();
LayerBallCarrier.ManialinkPage = BallCarrierFrame();

declare LayerMarkers <=> UIManager.UILayerCreate();
LayerMarkers.Type = CUILayer::EUILayerType::Markers;
LayerMarkers.ManialinkPage = GetMarkersLayer();

declare LayerTops <=> UIManager.UILayerCreate();

declare LayerExtra <=> UIManager.UILayerCreate();
***

***StartMap***
***
XmlRpc.SendCallback("beginMap", "");

// UI
UIManager.ResetAll();
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
// Clan scores at the top
UIManager.UIAll.OverlayScoreSummary = True;
UIManager.UIAll.ScoreSummary_MatchPoints1 = -1;
UIManager.UIAll.ScoreSummary_MatchPoints2 = -1;
// Name plates
SM::SetupDefaultVisibility();

// WarmUp
if (S_UseWarmUp) {
	WarmUp::Initialize(C_WarmUpDuration);
	WarmUp::Start();
}

UIManager.UIAll.SendNotice(
	_("New Match"), CUIConfig::ENoticeLevel::MatchInfo, 
	Null, CUIConfig::EAvatarVariant::Default, 
	CUIConfig::EUISound::StartMatch, 0);
	
// Teams layer
if (C_UseTeamsLayer) {
	LayerTeams.IsVisible = True;
	UIManager.UIAll.UILayers.add(LayerTeams);
}
// Tops layer
LayerTops.IsVisible = True;
UIManager.UIAll.UILayers.add(LayerTops);
// Ball carrier layer
LayerBallCarrier.IsVisible = True;
UIManager.UIAll.UILayers.add(LayerBallCarrier);

// Extra information layer
LayerExtra.IsVisible = True;
UIManager.UIAll.UILayers.add(LayerExtra);

LayerMarkers.IsVisible = True;
UIManager.UIAll.UILayers.add(LayerMarkers);

// Hide map warnings to suppress the "Pole captured by X" message
UIManager.UIAll.NoticesFilter_HideMapWarning = True;

// Auto team balance
if (S_AutoTeamBalance) {
	Mode::AutoTeamBalance();
	SM::UnspawnAllPlayers();
}

// Prepare match
Score::MatchBegin();
Top::MatchBegin();
Top::RoundBegin();
Victory::MatchBegin();
BalancedWeapons::MatchBegin();

ClanScores[1] = 0;
ClanScores[2] = 0;
G_Overtime = False;

// Prepare map
G_ClanSpawnIDs.clear();
G_ClanPoleIDs.clear();
G_BallPoleId = NullId;
G_ForwardSpawnId = NullId;
G_ForwardGoalId = NullId;

foreach (Base in Bases) {
	Base.IsActive = True;
	Base.Clan = 0;
}
foreach (Index => Spawn in BlockSpawns) {
	if (Spawn.Order == 0 && Spawn.Tag == "ForwardSpawn") {
		// Forward spawn
		G_ForwardSpawnId = Spawn.Id;
	} else {
		G_ClanSpawnIDs[Spawn.Order] = Spawn.Id;
	}
}
foreach (Index => Pole in BlockPoles) {
	switch (Pole.Order) {
		case 3: {
			// Ball spawn
			G_BallHomePosition = Pole.Position;
			G_BallPoleId = Pole.Id;
			Pole.Gauge.ValueReal = 1.0;
			Pole.Captured = True;
		}
		default: {
			if (Pole.Order == 0 && Pole.Tag == "ForwardGoal") {
				// Forward goal
				G_ForwardGoalId = Pole.Id;
				Pole.Gauge.Max = C_ForwardCaptureTime;
			} else {
				G_ClanPoleIDs[3-Pole.Order] = Pole.Id;
				Pole.Gauge.Max = C_NeededCaptureTime;
			}
		}
	}
}
G_ForwardActive = C_AllowForwardSpawns && (G_ForwardSpawnId != NullId) && (G_ForwardGoalId != NullId);

// Cache settings
Cache_S_FriendlyFire = S_FriendlyFire;
Cache_S_LaserBattle = S_LaserBattle;
---Rules---
***

***StartRound***
***
XmlRpc.SendCallback("beginRound", GetRankings());

if (!G_Overtime) {
	Score::RoundBegin();
}
Victory::RoundBegin();
BalancedWeapons::RoundBegin();

// UI
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
if (!G_Overtime) {
	LayerExtra.ManialinkPage = "";
	UIManager.UIAll.SendNotice(
		"", CUIConfig::ENoticeLevel::MatchInfo,
		Null, CUIConfig::EAvatarVariant::Default,
		CUIConfig::EUISound::StartRound, 0);
}

// Initialize values
if (!G_Overtime) {
	AssignSpawnPoleClans();
}
G_BallCarrierId = NullId;
G_BallDropPosition = G_BallHomePosition;
G_ExtraTimeStart = 0;
G_BallArmorRegTime = 0;
G_ResetTimeMessageStatus = 0;
G_ForwardClan = 0;
UpdateBaseClans();

// Clublinks
Clublink::DefineTeamsAuto();

// Set bots
SetNbFakePlayers(S_NbBotsBlue, S_NbBotsRed);

// Set round times
StartTime = Now + C_RespawnTime + 1000;
if (G_Overtime) {
	EndTime = StartTime + S_OvertimeLimit * 1000;
} else {
	EndTime = StartTime + S_TimeLimit * 1000;
}
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
***

***OnNewPlayer***
***
// Prepare UI for the new player
declare UI <=> UIManager.GetUI(Player);
if (UI != Null) {
	UI.UILayers.clear();
	UI.UILayers.add(LayerPosition);
	
	// Gauge ratio
	UI.GaugeRatio = -1.0;
}
***

***OnNewSpectator***
***
// Prepare UI for the new spectator
declare UI <=> UIManager.GetUI(Spectator);
if (UI != Null) {
	UI.UILayers.clear();
	
	// Gauge ratio
	UI.GaugeRatio = -1.0;
	
	// Spawn queue
	declare LastSpawnTime for Spectator = -1;
	if (LastSpawnTime >= 0) {
		LastSpawnTime = -1;
		if (UI.StatusMessage == T_WaitForSpawn) {
			UI.StatusMessage = "";
		}
	}
}
***

***PlayLoop***
***
// Handle afk players
if (C_ManageAFKPlayers && G_LastAfkHandling + 30000 < Now) {
	G_LastAfkHandling = Now;
	AFK::ManageAFKPlayers();
}
// Library updates
if (C_UseAchievements) {
	Achievements::OnLoop();
}
if (C_UsePlayerClublinks) {
	Clublink::DefineTeamsAuto();
}

// Update playing players
G_PlayingPlayerIDs.clear();
foreach (Player in Players) {
	declare LastSpawnTime for Player = -1;
	if (LastSpawnTime >= 0) {
		G_PlayingPlayerIDs.add(Player.Id);
	}
}

// Update waiting players
foreach (PlayerID in G_WaitingPlayerIDs) {
	if (!Players.existskey(PlayerID)) {
		declare Temp = G_WaitingPlayerIDs.remove(PlayerID);
	}
}

// Check for changed settings
declare UpdateRules = False;
if (Cache_S_FriendlyFire != S_FriendlyFire) {
	// FriendlyFire changed
	if (S_FriendlyFire) {
		UIManager.UIAll.SendChat("$<$f80Friendly Fire$> is now $<$0f0activated$>! (Pay attention to not damage your team mates!)");
	} else {
		UIManager.UIAll.SendChat("$<$f80Friendly Fire$> is now $<$f11deactivated$>!");
	}
	Cache_S_FriendlyFire = S_FriendlyFire;
	UpdateRules = True;
}
if (Cache_S_LaserBattle != S_LaserBattle) {
	// InstaGib changed
	if (S_LaserBattle) {
		UIManager.UIAll.SendChat("$<$f80LaserBattle$> is now $<$0f0activated$>! (Players spawn with lasers! Hits cause still 1 damage.)");
	} else {
		UIManager.UIAll.SendChat("$<$f80LaserBattle$> is now $<$f11deactivated$>!");
	}
	Cache_S_LaserBattle = S_LaserBattle;
	UpdateRules = True;
}
if (UpdateRules) {
	---Rules---
}

if (G_BallCarrierId != NullId) {
	if (!Players.existskey(G_BallCarrierId)) {
		// Ball carrier left the game
		DropBall();
	} else {
		// Track ball position
		G_LastBallPosition = Players[G_BallCarrierId].Position;
	}
} else {
	// Check if the dropped ball resets
	if (G_BallDropPosition != G_BallHomePosition && GetRmDrpdBallTime() <= 0) {
		ResetBall();
	}
}

// Perform actions for each player
foreach (Player in Players) {
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			// Player not spawned -> Spawn him!
			if (!Player.RequestsSpectate) {
				MySpawnPlayer(Player);
			}
		}
		case CSmPlayer::ESpawnStatus::Spawned: {
			// Check for respawn requests
			if (Player.CurrentClan != Player.RequestedClan || Player.RequestsSpectate) {
				DropBall(Player.Id);
				UnspawnPlayer(Player);
			} else {
				if (G_BallCarrierId == Player.Id) {
					// Ball carrier!
					// Highlighting
					Player.EnergyLevel = 1.0;
					// Regenerate armor
					Player.ArmorReplenishGain = C_BallCarrierArmorReplenishGain;
					// Use alternate ball weapon visual?
					if (C_UseAlternateBallWeaponVisual) {
						Player.UseAlternateWeaponVisual = True;
					}
				} else {
					// Usual player (without ball)
					Player.EnergyLevel = C_PlayerHighlightValue;
					if (G_BallCarrierId == NullId) {
						// Check if the player picks up the ball
						if (Player.Armor >= 100) {
							if (MathLib::Distance(Player.Position, G_BallDropPosition) <= C_BallPickUpDistance) {
								// Player picks up the ball
								PickUpBall(Player.Id);
							}
						}
					}
					// Reduce armor to even values if the player has partly regenerated armor
					Player.ArmorReplenishGain = 0;
					if (Player.Armor > 100 && Player.Armor < 200) {
						Player.Armor = 100;
					}
					// Disable alternate ball weapon visual
					if (Player.UseAlternateWeaponVisual) {
						Player.UseAlternateWeaponVisual = False;
					}
				}
			}
		}
	}
}

// Handle pending events
foreach (Event in PendingEvents) {
	if (C_UseAchievements) {
		Achievements::OnEvent(Event);
	}
	switch (Event.Type) {
		case CSmModeEvent::EType::OnArmorEmpty: {
			if (Event.Victim.Id == G_BallCarrierId) {
				// Ball carrier died -> Drop the ball
				DropBall(Event.Victim.Id);
			}
			if (Event.Shooter != Null && !Event.Shooter.IsFakePlayer && !Event.Victim.IsFakePlayer) {
				BalancedWeapons::OnOut(Event.Shooter, Event.Victim);
				XmlRpc.SendCallback("playerKill", "Victim:"^Event.Victim.Login^";Shooter:"^Event.Shooter.Login);
			}
			if (!Event.Victim.IsFakePlayer) {
				XmlRpc.SendCallback("playerDeath", Event.Victim.Login);
			}
			PassOn(Event);
		}
		case CSmModeEvent::EType::OnHit: {
			Event.Damage = 100;
			if (Event.Shooter == Null || Event.Victim == Null) {
				// Discard buggy event
				Discard(Event);
			} else {
				if (Event.Shooter == Event.Victim) {
					if (C_NucleusSelfDamage && (Event.Shooter.Id != G_BallCarrierId) && Event.WeaponNum == This.GetWeaponIndex(CSmMode::EWeapon::Nucleus)+1) {
						// Allow nucleus self damage
						declare Points = -1;
						Event.ShooterPoints = Points;
						// Decrease scores
						if (!Event.Shooter.IsFakePlayer || C_ShowBotsInTops) {
							Top::IncrementPlayerPoints(T_Backstabber, Event.Shooter, -Points);
						}
						if (C_DecrScoreOnFriendHit) {
							Score::AddPoints(Event.Shooter, Points);
						}
						PassOn(Event);
					} else {
						// Discard self damage
						Discard(Event);
					}
				} else {
					if (Event.Shooter.Id == G_BallCarrierId) {
						// Ball carrier hit someone -> Pass the ball
						PassBall(Event.Shooter.Id, Event.Victim.Id);
						Discard(Event);
					} else {
						if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
							if (S_FriendlyFire) {
								// Friendly fire hits
								declare Points = -1;
								if (Event.Victim.Id == G_BallCarrierId) {
									Points *= 2;
								}
								Event.ShooterPoints = Points;
								// Decrease scores
								if (!Event.Shooter.IsFakePlayer || C_ShowBotsInTops) {
									Top::IncrementPlayerPoints(T_Backstabber, Event.Shooter, -Points);
								}
								if (C_DecrScoreOnFriendHit) {
									Score::AddPoints(Event.Shooter, Points);
								}
								// Kill victim if he hasn't full armor
								if (Event.Victim.Armor < 200) {
									Event.Damage = Event.Victim.Armor;
								}
								// Show team hit warning
								if (C_NbTeamHitMessage != 0) {
									declare UI <=> UIManager.GetUI(Event.Shooter);
									if (UI != Null) {
										declare NbTeamHitMessage for UI = 0;
										if (C_NbTeamHitMessage < 0 || NbTeamHitMessage < C_NbTeamHitMessage) {
											UI.StatusMessage = T_TeamHitMessage;
											NbTeamHitMessage += 1;
											declare LastStatusMessage for UI = 0;
											LastStatusMessage = Now;
										}
									}
								}
								PassOn(Event);
							} else {
								// Discard team hits
								Discard(Event);
							}
						} else {
							// Calculate points for the hit
							declare Points = 1;
							if (Event.Victim.Id == G_BallCarrierId) {
								Points *= 2;
							}
							Event.ShooterPoints = Points;
							Score::AddPoints(Event.Shooter, Points);
							if (!Event.Shooter.IsFakePlayer || C_ShowBotsInTops) {
								Top::IncrementPlayerPoints(T_Damage, Event.Shooter, Points);
							}
							// Kill victim if he hasn't full armor
							if (Event.Victim.Armor < 200) {
								Event.Damage = Event.Victim.Armor;
							}
							if (!Event.Shooter.IsFakePlayer && !Event.Victim.IsFakePlayer) {
								XmlRpc.SendCallback("playerHit", "Victim:"^Event.Victim.Login^";Shooter:"^Event.Shooter.Login^";"^Points);
							}
							PassOn(Event);
						}
					}
				}
			}
		}
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
			if (Event.Player.Id == G_BallCarrierId) {
				// Ball carrier requested respawn -> Drop the ball
				DropBall(Event.Player.Id);
			}
			MySpawnPlayer(Event.Player);
			if (!Event.Player.IsFakePlayer) {
				XmlRpc.SendCallback("playerRespawn", Event.Player.Login);
			}
			Discard(Event);
		}
		case CSmModeEvent::EType::OnCapture: {
			if (Event.BlockPole.Id == G_ForwardGoalId) {
				// Forward goal
				PassOn(Event);
			} else {
				if (G_BallCarrierId != NullId) {
					// Captured! - Announce winner etc.
					Victory::SetRoundWinnerIfNoWinner(Event.BlockPole.Gauge.Clan);
					UIManager.UIAll.BigMessage = "";
					declare Message = "";
					if (G_BallCarrierId != NullId) {
						Message = TextLib::Compose(_("$<%1$> scores for $<%2$>!"), Players[G_BallCarrierId].Name, Teams[Players[G_BallCarrierId].CurrentClan-1].ColorizedName);
						// Reward ball carrier
						Score::AddPoints(Players[G_BallCarrierId], 5);
						if (!Players[G_BallCarrierId].IsFakePlayer || C_ShowBotsInTops) {
							Top::IncrementPlayerPoints(T_Captures, Players[G_BallCarrierId], 1);
						}
						if (!Players[G_BallCarrierId].IsFakePlayer) {
							XmlRpc.SendCallback("poleCapture", Players[G_BallCarrierId].Login);
						}
					} else {
						Message = TextLib::Compose(_("$<%1$> captured the goal!"), Teams[Players[G_BallCarrierId].CurrentClan-1].ColorizedName);
					}
					UIManager.UIAll.SendNotice(
						Message, CUIConfig::ENoticeLevel::MatchInfo,
						Null, CUIConfig::EAvatarVariant::Default,
						CUIConfig::EUISound::Capture, 0);
					PassOn(Event);
				} else {
					Discard(Event);
				}
			}
		}
		case CSmModeEvent::EType::OnNearMiss: {
			// Near miss
			if (!Event.Shooter.IsFakePlayer && C_NearMissDist >= 0 && Event.MissDist <= C_NearMissDist) {
				declare UI <=> UIManager.GetUI(Event.Shooter);
				if (UI != Null) {
					UI.StatusMessage = GetNearMissMessage(Event);
					declare LastStatusMessage for UI = 0;
					LastStatusMessage = Now;
				}
			}
			PassOn(Event);
		}
		default: {
			PassOn(Event);
		}
	}
}

// Check for captures
foreach (Pole in BlockPoles) {
	// Team Goals
	if (G_ClanPoleIDs.exists(Pole.Id)) {
		if (Victory::NoRoundWinner()) {
			Pole.Gauge.Speed = -C_NeededCaptureTime;
		}
		declare BallAtPole = False;
		if (G_BallCarrierId != NullId) {
			foreach (PlayerId in Pole.Sector.PlayersIds) {
				if (Players.existskey(PlayerId) &&
					PlayerId == G_BallCarrierId &&
					Pole.Id == G_ClanPoleIDs[Players[PlayerId].CurrentClan]) {
					if (G_Overtime) {
						Pole.Gauge.ValueReal = 1.0;
						Pole.Gauge.Speed = C_NeededCaptureTime;
					} else {
						Pole.Gauge.Speed = 1;
					}
					// Gauge ratio
					declare UI <=> UIManager.GetUI(Players[PlayerId]);
					if (UI != Null) {
						UI.GaugeClan = Players[PlayerId].CurrentClan;
						UI.GaugeRatio = Pole.Gauge.ValueReal;
					}
					BallAtPole = True;
					break;
				}
			}
		}
		if (!BallAtPole) {
			// Prevent weird bug causing the pole stay fully captured without an OnCapture event
			if (!Pole.Captured && Pole.Gauge.ValueReal >= 1.0 && Now < EndTime) {
				Pole.Gauge.ValueReal = 0.0;
			}
		}
	}
	
	// Forward goal
	if (G_ForwardActive && BlockPoles.existskey(G_ForwardGoalId)) {
		declare Pole <=> BlockPoles[G_ForwardGoalId];
		Pole.Gauge.Speed = 0;
		
		if (Pole.Gauge.ValueReal == 0.0) {
			Pole.Gauge.Clan = 0;
		} else {
			if (Pole.Gauge.ValueReal >= C_ForwardCapturePercentage) {
				G_ForwardClan = Pole.Gauge.Clan;
			} else {
				G_ForwardClan = 0;
			}
		}
		
		declare Speed = [1 => 0, 2 => 0];
		foreach (PlayerId in Pole.Sector.PlayersIds) {
			if (Players.existskey(PlayerId)) {
				Speed[Players[PlayerId].CurrentClan] += 1;
			}
		}
		switch (Pole.Gauge.Clan) {
			case 0: {
				// Pole is not yet captured
				for (Clan, 1, 2) {
					if (Speed[Clan] > Speed[3-Clan]) {
						// Clan started capturing the pole
						Pole.Gauge.Clan = Clan;
						Pole.Gauge.Speed = Speed[Clan];
						break;
					}
				}
			}
			default: {
				// Pole has been captured partly
				if (Speed[Pole.Gauge.Clan] > Speed[3-Pole.Gauge.Clan]) {
					// Pole gets captured further
					Pole.Gauge.Speed = Speed[Pole.Gauge.Clan];
				} else {
					if (Speed[3-Pole.Gauge.Clan] > Speed[Pole.Gauge.Clan]) {
						// Pole gets decaptured
						Pole.Gauge.Speed = -Speed[3-Pole.Gauge.Clan];
					}
				}
			}
		}
		
		UpdateBaseClans();
	}
}

// UI updates
if (G_LastUIUpdate + C_UITickInterval < Now) {
	G_LastUIUpdate = Now;
	
	// Gauge ratio
	foreach (Player in Players) {
		if (G_BallCarrierId == NullId || G_BallCarrierId != Player.Id || BlockPoles[G_ClanPoleIDs[3-Player.CurrentClan]].Gauge.ValueReal <= 0) {
			declare UI <=> UIManager.GetUI(Player);
			if (UI != Null) {
				UI.GaugeRatio = -1.0;
			}
		}
	}
	
	// Top rankings
	if (C_UseTops) {
		declare TopNb = 3;
		if (S_FriendlyFire) {
			TopNb += 1;
		}
		declare Position = "129 -30";
		switch (((Now - StartTime) / 7000) % TopNb) {
			case 0: {
				LayerTops.ManialinkPage = GetFrameTop(T_Damage, Position);
			}
			case 1: {
				LayerTops.ManialinkPage = GetFrameTop(T_Captures, Position);
			}
			case 2: {
				LayerTops.ManialinkPage = GetFrameTop(T_Passes, Position);
			}
			case 3: {
				LayerTops.ManialinkPage = GetFrameTop(T_Backstabber, Position);
			}
		}
	}
	
	// Clear big messages
	if (G_LastBigMessage > 0 && G_LastBigMessage + 5000 < Now) {
		UIManager.UIAll.BigMessage = "";
		G_LastBigMessage = 0;
	}
	
	// Clear status messages
	if (G_LastStatusMessage > 0 && G_LastStatusMessage + 5000 < Now) {
		UIManager.UIAll.StatusMessage = "";
		G_LastStatusMessage = 0;
	}
	
	// Clan scores at the top
	UpdateClanScoresSummary();
	
	// Update markers
	UpdateHud3dMarkers();
	LayerMarkers.ManialinkPage = GetMarkersLayer();
	
	// Extra layer
	LayerExtra.ManialinkPage = GetLayerExtra();
	
	// Ball carrier frame
	LayerBallCarrier.ManialinkPage = BallCarrierFrame();
	
	declare CurrentBallCarrierClan = 0;
	if (G_BallCarrierId != NullId && Players.existskey(G_BallCarrierId)) {
		CurrentBallCarrierClan = Players[G_BallCarrierId].CurrentClan;
	}
	declare RemainingDropTime = GetRmDrpdBallTime();
	
	// Update players UI
	foreach (Player in Players) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null) {
			// Update net values
			declare netwrite Integer Net_CurrentBallCarrierClan for UI;
			Net_CurrentBallCarrierClan = CurrentBallCarrierClan;
			if (CurrentBallCarrierClan == 0) {
				declare netwrite Integer Net_RemainingDropTime for UI;
				Net_RemainingDropTime = RemainingDropTime;
			}
			declare netwrite Integer Net_ForwardClan for UI;
			Net_ForwardClan = G_ForwardClan;
			
			// Update layers
			UpdatePositionLayer(Player);
			
			// Update crosshair extension
			if (G_BallCarrierId != NullId && G_BallCarrierId == Player.Id) {
				UI.ManialinkPage = """
				<label posn="0 7" halign="center" scale="2" textprefix="{{{Teams[Player.CurrentClan-1].ColorText}}}" text="〝     〞" style="TextCardSmallScores1"/>
				<label posn="0 -8" halign="center" scale="1" textprefix="{{{Teams[Player.CurrentClan-1].ColorText}}}$n$o" text="{{{_("shoot to pass")}}}" style="TextCardSmallScores2"/>""";
			} else {
				UI.ManialinkPage = "";
			}
			
			// Clear player status message
			declare LastStatusMessage for UI = 0;
			if ((LastStatusMessage > 0 && LastStatusMessage + 4500 < Now) || UI.StatusMessage == T_WaitForSpawn) {
				UI.StatusMessage = "";
				LastStatusMessage = 0;
			}
		}
	}
	
	// Update spectators UI
	foreach (Spectator in Spectators) {
		declare UI <=> UIManager.GetUI(Spectator);
		if (UI != Null) {
			// Update net values
			declare netwrite Integer Net_CurrentBallCarrierClan for UI;
			Net_CurrentBallCarrierClan = CurrentBallCarrierClan;
			if (CurrentBallCarrierClan == 0) {
				declare netwrite Integer Net_RemainingDropTime for UI;
				Net_RemainingDropTime = RemainingDropTime;
			}
			
			// Update crosshair extension
			UI.ManialinkPage = "";
			
			// Clear spectator status message
			declare LastStatusMessage for UI = 0;
			if (LastStatusMessage > 0 && LastStatusMessage + 4500 < Now && UI.StatusMessage != "") {
				UI.StatusMessage = "";
				LastStatusMessage = 0;
			}
		}
	}
}

// Check round end conditions
if (Now >= EndTime) {
	// Time is up
	if (G_BallCarrierId == NullId) {
		// Ball is dropped
		declare EndRound = False;
		if (C_EndRoundOnDrop) {
			// On drop variant - end round
			EndRound = True;
		} else {
			// On reset variant
			if (G_BallHomePosition == G_BallDropPosition) {
				// @Home - End round
				EndRound = True;
			}
		}
		if (EndRound) {
			// Perform round end and start overtime
			Victory::SetRoundDrawIfNoWinner();
			MB_StopRound = True;
			G_Overtime = !G_Overtime;
		}
	} else {
		// Ball isn't dropped
		if (G_Overtime && G_BallCarrierId != NullId && Players.existskey(G_BallCarrierId)) {
			// Win by holding the ball long enough
			Victory::SetRoundWinnerIfNoWinner(Players[G_BallCarrierId].CurrentClan);
		} else {
			// Keep going
			if (EndTime != -1) {
				EndTime = -1;
				G_ExtraTimeStart = Now - 2000;
			}
			StartTime = G_ExtraTimeStart;
		}
	}
	
	// Messages for the decreasing reset time
	if (!G_Overtime && !C_EndRoundOnDrop && C_TimeToDecResetTime1Sec > 0 && !MB_StopRound) {
		switch (G_ResetTimeMessageStatus) {
			case 0: {
				declare Message = "The time to reset the ball starts decreasing...";
				UIManager.UIAll.SendChat(Message);
				G_ResetTimeMessageStatus = 1;
			}
			case 1: {
				if (GetRmDrpdBallTime() <= 0) {
					declare Message = "The ball resets instantly now!";
					UIManager.UIAll.SendChat(Message);
					G_ResetTimeMessageStatus = 2;
				}
			}
		}
	}
}
if (!MB_StopRound && !Victory::NoRoundWinner()) {
	// Round winner found
	MB_StopRound = True;
	if (G_Overtime) {
		G_Overtime = False;
	}
}
***

***EndRound***
***
XmlRpc.SendCallback("endRound", GetRankings());

UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
if (G_Overtime) {
	UIManager.UIAll.SendNotice(
		"", CUIConfig::ENoticeLevel::MatchInfo,
		Null, CUIConfig::EAvatarVariant::Default,
		CUIConfig::EUISound::EndRound, 0);
}

ResetUIs();
StartTime = -1;
EndTime = -1;
SM::UnspawnAllPlayers();
UIManager.UIAll.Hud3dMarkers = "";
LayerMarkers.ManialinkPage = "";
MB_Sleep(3000);

if (G_Overtime) {
	if (!MB_StopMap && !MatchEndRequested) {
		UIManager.UIAll.SendNotice(
			TextLib::Compose("$f00%1!", T_Overtime), CUIConfig::ENoticeLevel::PlayerInfo,
			Null, CUIConfig::EAvatarVariant::Default,
			CUIConfig::EUISound::StartRound, 0);
		UIManager.UIAll.BigMessage = TextLib::Compose("$f00%1!", T_Overtime);
		UIManager.UIAll.StatusMessage = TextLib::Compose(_("Hold the %1 for %2 seconds or capture instantly!"), T_Ball, TextLib::ToText(S_OvertimeLimit));
		G_LastBigMessage = Now;
		G_LastStatusMessage = Now;
		
		MB_Sleep(3000);
	}
} else {
	// Evaluate round
	declare Message = _("Round Draw");
	if (!Victory::IsRoundDraw()) {
		for (Index, 1, 2) {
			if (Victory::IsRoundWinner(Index)) {
				// Team 'Index' wins the round
				ClanScores[Index] += 1;
				Message = TextLib::Compose(_("%1 wins the round!"), Teams[Index-1].ColorizedName);
				UpdateClanScoresSummary();
				break;
			}
		}
	}
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.SendNotice(
		Message, CUIConfig::ENoticeLevel::MatchInfo,
		Null, CUIConfig::EAvatarVariant::Default,
		CUIConfig::EUISound::EndRound, 0);
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
	
	// Show all top lists
	if (C_UseTops) {
		declare ManialinkPage = "";
		
		ManialinkPage =	GetFrameTop(T_Damage, "129 40")
						^
						GetFrameTop(T_Captures, "129 5")
						^
						GetFrameTop(T_Passes, "129 -30");
		if (S_FriendlyFire) {
			ManialinkPage ^= GetFrameTop(T_Backstabber, "-129 30");
		}
		
		LayerTops.ManialinkPage = ManialinkPage;
	}
	
	// Check match end conditions
	Victory::SetMatchWinnerFromScore(S_RoundsToWin, S_RoundGapToWin, S_RoundsLimit);
	if (!Victory::NoMatchWinner()) {
		// Match winner found
		MB_StopMap = True;
	}
	
	// Wait to let the players take a breath
	MB_Sleep(4000);
	
	Score::RoundEnd();
}
Victory::RoundEnd();
BalancedWeapons::RoundEnd();
***

***EndMap***
***
XmlRpc.SendCallback("endMap", GetRankings());

Score::MatchEnd();
Top::RoundEnd();
Top::MatchEnd();
Victory::MatchEnd();
BalancedWeapons::MatchEnd();

// UI
UIManager.UIAll.BigMessage = "";
UIManager.UIAll.StatusMessage = "";
UIManager.UIAll.Hud3dMarkers = "";
UIManager.UIAll.ManialinkPage = "";
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;

// Hide useless layers
if (C_HideStuffAtMapEnd) {
	// Custom layers
	LayerPosition.IsVisible = False;
	LayerBallCarrier.IsVisible = False;
	LayerTops.IsVisible = False;
	LayerTeams.IsVisible = False;
	LayerMarkers.IsVisible = False;
	LayerExtra.IsVisible = False;
}

// Announce victorious clan
declare Message = _("Match Draw");
if (!Victory::IsMatchDraw()) {
	for (Index, 1, 2) {
		if (Victory::IsMatchWinner(Index)) {
			// Team 'Index' wins the match
			Message = TextLib::Compose(_("%1 wins the match!"), Teams[Index-1].ColorizedName);
			break;
		}
	}
}
UIManager.UIAll.SendNotice(
	Message, CUIConfig::ENoticeLevel::MatchInfo, 
	Null, CUIConfig::EAvatarVariant::Default, 
	CUIConfig::EUISound::EndMatch, 0);

MB_Sleep(4000);

Mode::Ladder_CloseMatch();

// Save spawned players for the next map
G_SpawnedPlayerIDs.clear();
foreach (Player in Players) {
	declare LastSpawnTime for Player = -1;
	if (LastSpawnTime >= 0) {
		G_SpawnedPlayerIDs.add(Player.Id);
	}
}

Clublink::DefineTeamsDefault();
***

***EndServer***
***

// UI Cleanup
SpawnScreen::DetachRules();
UIManager.UILayerDestroy(LayerTeams);
UIManager.UILayerDestroy(LayerPosition);
UIManager.UILayerDestroy(LayerBallCarrier);
UIManager.UILayerDestroy(LayerTops);

SpawnScreen::DestroyRules();
Color::Unload();
UIManager.UIAll.NoticesFilter_HideMapWarning = False;

if (C_UseAchievements) {
	Achievements::ResetTop("all");
}
***

/*****************************************************
	FUNCTIONS
*****************************************************/

// Set bot power
Void SetBotPower(CSmPlayer _Player) {
	if (_Player.IsFakePlayer) {
		// Ammunition
		declare BotPower = S_BotPower;
		if (BotPower > 10.0) {
			BotPower = 10.0;
		}
		_Player.AmmoGain = BotPower;
		
		// Armor
		declare ArmorMax = MathLib::NearestInteger(BotPower * 100);
		if (ArmorMax > 1000) {
			ArmorMax = 1000;
		} else {
			if (ArmorMax < 100) {
				ArmorMax = 100;
			}
		}
		_Player.ArmorMax = ArmorMax;
		
		// Agressivity
		_Player.BotAgressivity = BotPower;
	}
}

// Spawn player
Void MySpawnPlayer(CSmPlayer _Player) {
	UnspawnPlayer(_Player);
	
	// Check if the player is allowed to spawn
	declare SpawnAllowed = False;
	declare LastSpawnTime for _Player = -1;
	if (S_MaxPlayerCount <= 0 || LastSpawnTime >= 0 || G_SpawnedPlayerIDs.exists(_Player.Id)) {
		// Player has already been spawned
		SpawnAllowed = True;
	} else {
		if (G_PlayingPlayerIDs.count < S_MaxPlayerCount && G_WaitingPlayerIDs.count > 0 && G_WaitingPlayerIDs[0] == _Player.Id) {
			// Player is the longest waiting one
			SpawnAllowed = True;
		}
	}
	
	if (SpawnAllowed) {
		// Set bot power
		SetBotPower(_Player);
		
		// Set player weapon
		BalancedWeapons::SetPlayerWeapon(_Player, True);
		if (S_LaserBattle) {
			This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Laser, False);
			_Player.AmmoGain += C_InstaGibExtraAmmoGain;
		} else {
			This.SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
			_Player.AmmoGain += C_NormalExtraAmmoGain;
		}
		
		// Calculate spawn time
		declare SpawnTime = StartTime;
		if (Now > SpawnTime) {
			SpawnTime = Now + C_RespawnTime;
		}
		LastSpawnTime = SpawnTime;
		
		if (!G_PlayingPlayerIDs.exists(_Player.Id)) {
			G_PlayingPlayerIDs.add(_Player.Id);
		}
		declare SpawnId = NullId;
		if (G_ForwardActive && G_ForwardClan == _Player.RequestedClan) {
			declare UI <=> UIManager.GetUI(_Player);
			if (UI != Null) {
				declare netread Net_ForwardSpawnOn for UI = False;
				if (Net_ForwardSpawnOn) {
					SpawnId = G_ForwardSpawnId;
				}
			}
		}
		if (SpawnId == NullId) {
			SpawnId = G_ClanSpawnIDs[_Player.RequestedClan];
		}
		SM::SpawnPlayer(_Player, _Player.RequestedClan, BlockSpawns[SpawnId], SpawnTime);
		if (C_LogEnabled) MB_Log("""Spawning player: {{{_Player.Login}}}""");
		
		// Remove player from waiting queue
		if (G_WaitingPlayerIDs.exists(_Player.Id)) {
			declare Temp = G_WaitingPlayerIDs.remove(_Player.Id);
		}
	} else {
		// Add player to waiting queue
		if (!G_WaitingPlayerIDs.exists(_Player.Id)) {
			G_WaitingPlayerIDs.add(_Player.Id);
		}
		
		// Display waiting message
		declare UI <=> UIManager.GetUI(_Player);
		if (UI != Null) {
			if (UI.StatusMessage == "") {
				UI.StatusMessage = T_WaitForSpawn;
			}
		}
	}
}

// Set clans of spawns and poles at start of map and each round (changing sides)
Void AssignSpawnPoleClans() {
	if (C_LogEnabled) MB_Log("AssignSpawnPoleClans");
	
	// SPAWNS
	// Forward spawn
	if (BlockSpawns.existskey(G_ForwardSpawnId)) {
		BlockSpawns[G_ForwardSpawnId].Base.Clan = 0;
	}
	// Change sides
	declare FirstSpawns = G_ClanSpawnIDs[1];
	G_ClanSpawnIDs[1] = G_ClanSpawnIDs[2];
	G_ClanSpawnIDs[2] = FirstSpawns;
	// Assign clans
	foreach (Order => Id in G_ClanSpawnIDs) {
		switch (BlockSpawns[Id].Base.Clan) {
			case 0: {
				if (Order != 3) {
					BlockSpawns[Id].Base.Clan = Order;
				}
			}
			default: {
				BlockSpawns[Id].Base.Clan = 3-BlockSpawns[Id].Base.Clan;
			}
		}
	}
	
	// POLES
	// Forward goal
	if (BlockPoles.existskey(G_ForwardGoalId)) {
		BlockPoles[G_ForwardGoalId].Gauge.Clan = 0;
		BlockPoles[G_ForwardGoalId].Gauge.ValueReal = 0.0;
		BlockPoles[G_ForwardGoalId].Base.Clan = 0;
	}
	// Edit ball pole
	if (G_BallPoleId != NullId && BlockPoles.existskey(G_BallPoleId)) {
		BlockPoles[G_BallPoleId].Base.Clan = 0;
		BlockPoles[G_BallPoleId].Gauge.Clan = 0;
	}
	
	// Change sides
	declare FirstPole = G_ClanPoleIDs[1];
	G_ClanPoleIDs[1] = G_ClanPoleIDs[2];
	G_ClanPoleIDs[2] = FirstPole;
	// Prepare poles stuff
	foreach (Order => Id in G_ClanPoleIDs) {
		// Initialize values
		BlockPoles[Id].Captured = False;
		BlockPoles[Id].Gauge.ValueReal = 0.0;
		BlockPoles[Id].Gauge.Speed = 0;
		
		// Assign clans
		switch (BlockPoles[Id].Gauge.Clan) {
			case 0: {
				if (Order != 3) {
					BlockPoles[Id].Gauge.Clan = Order;
					BlockPoles[Id].Base.Clan = BlockPoles[Id].Gauge.Clan;
				}
			}
			default: {
				BlockPoles[Id].Gauge.Clan = 3-BlockPoles[Id].Gauge.Clan;
				BlockPoles[Id].Base.Clan = BlockPoles[Id].Gauge.Clan;
			}
		}
	}
}

// Update clans of bases
Void UpdateBaseClans() {
	// Forward spawn
	if (G_ForwardActive) {
		if (BlockSpawns.existskey(G_ForwardSpawnId)) {
			BlockSpawns[G_ForwardSpawnId].Base.Clan = G_ForwardClan;
		}
		if (BlockPoles.existskey(G_ForwardGoalId)) {
			BlockPoles[G_ForwardGoalId].Base.Clan = G_ForwardClan;
		}
	}
	
	if (G_BallCarrierId == NullId) {
		// Ball dropped - Reset base clan of the ball pole
		if (G_BallPoleId != NullId && BlockPoles.existskey(G_BallPoleId)) {
			BlockPoles[G_BallPoleId].Base.Clan = 0;
			BlockPoles[G_BallPoleId].Gauge.Clan = 0;
		}
	} else {
		// A clan carries the ball - Set carrying clan to ball pole
		if (Players.existskey(G_BallCarrierId) && G_BallPoleId != NullId && BlockPoles.existskey(G_BallPoleId)) {
			BlockPoles[G_BallPoleId].Base.Clan = Players[G_BallCarrierId].CurrentClan;
			BlockPoles[G_BallPoleId].Gauge.Clan = Players[G_BallCarrierId].CurrentClan;
		}
		// Bases screw things up on some maps - Perform fix if needed
		if (G_ClanPoleIDs.existskey(1) && G_ClanPoleIDs.existskey(2) && G_ClanPoleIDs[1] != NullId && G_ClanPoleIDs[2] != NullId) {
			if (BlockPoles.existskey(G_ClanPoleIDs[1]) && BlockPoles.existskey(G_ClanPoleIDs[2]) && BlockPoles[G_ClanPoleIDs[1]].Base == BlockPoles[G_ClanPoleIDs[2]].Base) {
				// Poles of the teams share the same base -.-
				// Change the clan of the base to the clan currently carrying the ball
				BlockPoles[G_ClanPoleIDs[Players[G_BallCarrierId].CurrentClan]].Base.Clan = Players[G_BallCarrierId].CurrentClan;
			}
		}
	}
}

// Player picks up the ball
Void PickUpBall(Ident _PlayerId) {
	// Perform several checks if picking up is allowed right now because of weird bugs of the game itself
	if (G_BallCarrierId == NullId && Players.existskey(_PlayerId) && (Now < EndTime || G_BallDropPosition != G_BallHomePosition) && Now >= StartTime && Players[_PlayerId].Armor > 0 && (C_BotsCanHaveBall || !Players[_PlayerId].IsFakePlayer)) {
		G_BallCarrierId = _PlayerId;
		UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> has the $<%2%3$>!"), Players[_PlayerId].Name, Teams[Players[_PlayerId].CurrentClan-1].ColorText, T_Ball);
		G_LastBigMessage = Now;
		Score::AddPoints(Players[_PlayerId], 2);
		if (G_Overtime) {
			// Start countdown
			EndTime = Now + S_OvertimeLimit * 1000;
		}
		UpdateBaseClans();
		if (C_LogEnabled) MB_Log("""{{{Players[_PlayerId].Login}}} picked up the {{{T_Ball}}}!""");
	}
}

Void ResetBall() {
	G_BallCarrierId = NullId;
	G_BallDropPosition = G_BallHomePosition;
	if (G_ExtraTimeStart == 0) {
		UIManager.UIAll.BigMessage = T_BallReset;
		G_LastBigMessage = Now;
	}
	UpdateBaseClans();
	if (G_Overtime) {
		// Start countdown
		EndTime = Now + S_OvertimeLimit * 1000;
	}
	if (C_LogEnabled) MB_Log(T_BallReset);
}

// Ball carrier drops the ball
Void DropBall(Ident _PlayerId) {
	if (_PlayerId == NullId || !Players.existskey(_PlayerId) || _PlayerId == G_BallCarrierId) {
		declare Vec3 BallPosition;
		declare Text Message;
		
		// Get values of the dropped ball
		if (_PlayerId == NullId || !Players.existskey(_PlayerId)) {
			// Player left
			BallPosition = G_LastBallPosition;
			Message = TextLib::Compose(_("%1 dropped!"), T_Ball);
			
			if (C_LogEnabled) MB_Log("""Ball carrier {{{G_BallCarrierId}}} left the game -> Drop at {{{G_LastBallPosition}}}!""");
		} else {
			// Player still ingame
			BallPosition = Players[_PlayerId].Position;
			Message = TextLib::Compose(_("$<%1$> dropped the %2!"), Players[_PlayerId].Name, T_Ball);
			
			if (C_LogEnabled) MB_Log("""{{{Players[_PlayerId].Login}}} dropped the {{{T_Ball}}}!""");
		}
		
		// Perform drop
		G_BallCarrierId = NullId;
		G_BallDropPosition = BallPosition;
		UIManager.UIAll.BigMessage = Message;
		G_LastBigMessage = Now;
		G_BallDropTime = Now;
		G_LastBallResetSeconds = MathLib::CeilingInteger(C_DroppedBallResetTime / 1000.0);
		UpdateBaseClans();
		if (G_Overtime) {
			// Start countdown
			EndTime = Now + S_OvertimeLimit * 1000;
		}
	}
}

Void DropBall() {
	DropBall(NullId);
}

// Player gets passed the ball
Void PassBall(Ident _ShooterId, Ident _VictimId) {
	// Perform several checks if passing is allowed right now because of weird event bugs of the game itself
	if (_ShooterId != NullId && _VictimId != NullId && Players.existskey(_ShooterId) && Players.existskey(_VictimId) && Now > StartTime) {
		if (G_BallCarrierId != NullId && G_BallCarrierId == _ShooterId && Players[_VictimId].StartTime < Now && Players[_ShooterId].Armor > 0 && Players[_VictimId].Armor > 0 && (C_BotsCanHaveBall || !Players[_VictimId].IsFakePlayer)) {
			if (!S_LaserBattle || C_LongestInstaPassDist <= 0.0 || MathLib::Distance(Players[_ShooterId].Position, Players[_VictimId].Position) <= C_LongestInstaPassDist) {
				G_BallCarrierId = _VictimId;
				UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> has the $<%2%3$>!"), Players[_VictimId].Name, Teams[Players[_VictimId].CurrentClan-1].ColorText, T_Ball);
				G_LastBigMessage = Now;
				if (Players[_ShooterId].CurrentClan == Players[_VictimId].CurrentClan) {
					// Team pass -> Grant points!
					Score::AddPoints(Players[_ShooterId], 2);
					if (!Players[_ShooterId].IsFakePlayer || C_ShowBotsInTops) {
						Top::IncrementPlayerPoints(T_Passes, Players[_ShooterId], 1);
					}
					if (!Players[_ShooterId].IsFakePlayer) {
						XmlRpc.SendCallback("passBall", "Shooter:"^Players[_ShooterId].Login^";Victim:"^Players[_VictimId].Login);
					}
				} else {
					// Pass to opponent
					if (G_Overtime) {
						// Start countdown
						EndTime = Now + S_OvertimeLimit * 1000;
					}
					UpdateBaseClans();
				}
				if (C_LogEnabled) MB_Log("""{{{Players[_ShooterId].Login}}} passed the {{{T_Ball}}} to {{{Players[_VictimId].Login}}}!""");
			} else {
				if (C_LongestInstaPassDist > 0.0) {
					// Show pass distance difference
					declare UI <=> UIManager.GetUI(Players[_ShooterId]);
					if (UI != Null) {
						declare LastStatusMessage for UI = 0;
						declare DistanceDiff =  MathLib::NearestInteger(MathLib::Distance(Players[_ShooterId].Position, Players[_VictimId].Position) - C_LongestInstaPassDist);
						UI.StatusMessage = TextLib::Compose(_("%1m too far away!"), TextLib::ToText(DistanceDiff));
						LastStatusMessage = Now;
					}
				}
			}
		}
	}
}

// Updates clan scores at the top
Void UpdateClanScoresSummary() {
	declare PlayerClan1Id = NullId;
	declare PlayerClan2Id = NullId;
	foreach (Player in Players) {
		if (PlayerClan1Id == NullId && Player.CurrentClan == 1) {
			PlayerClan1Id = Player.Id;
		} else {
			if (PlayerClan2Id == NullId && Player.CurrentClan == 2) {
				PlayerClan2Id = Player.Id;
			} else {
				if (PlayerClan1Id != NullId && PlayerClan2Id != NullId) {
					break;
				}
			}
		}
	}
	if (PlayerClan1Id != NullId && PlayerClan2Id != NullId) {
		UIManager.UIAll.OverlayScoreSummary = True;
		UIManager.UIAll.ScoreSummary_Player1 = PlayerClan1Id;
		UIManager.UIAll.ScoreSummary_Points1 = ClanScores[Players[PlayerClan1Id].CurrentClan];
		UIManager.UIAll.ScoreSummary_Player2 = PlayerClan2Id;
		UIManager.UIAll.ScoreSummary_Points2 = ClanScores[Players[PlayerClan2Id].CurrentClan];
	} else {
		UIManager.UIAll.OverlayScoreSummary = False;
	}
}

// Returns the remaining time of the dropped ball until it resets
Integer GetRmDrpdBallTime() {
	// Calculate standard remaining time
	declare DropTime = Now;
	if (G_BallCarrierId == NullId) {
		DropTime = G_BallDropTime;
	}
	declare RemainingTime = C_DroppedBallResetTime - (Now - DropTime);
	// Decrease time if necessary
	if (!C_EndRoundOnDrop && C_TimeToDecResetTime1Sec > 0 && EndTime < 0) {
		declare MinusSeconds = (Now - StartTime) / C_TimeToDecResetTime1Sec;
		RemainingTime -= MinusSeconds;
	}
	return RemainingTime;
}

// Call carrier frame
Text BallCarrierFrame() {
	declare WindowStyle = 3;
	declare ClanMarker = "";
	declare ClanMarkerColor = "";
	declare BallCarrierName = _("Home");
	if (G_BallCarrierId == NullId) {
		if (G_BallDropPosition != G_BallHomePosition) {
			BallCarrierName = TextLib::Compose(_("Dropped (%1)"), TextLib::ToText(MathLib::NearestInteger(GetRmDrpdBallTime() / 1000.0)));
		}
	} else {
		if (Players.existskey(G_BallCarrierId)) {
			BallCarrierName = """$<{{{Players[G_BallCarrierId].Name}}}$>""";
			
			// Get color of clan marker
			if (Teams.existskey(Players[G_BallCarrierId].CurrentClan-1)) {
				ClanMarkerColor = TextLib::SubString(Teams[Players[G_BallCarrierId].CurrentClan-1].ColorText, 1, 3);
			}
		} else {
			BallCarrierName = "";
		}
	}
	
	if (G_Overtime) {
		// Special overtime style
		WindowStyle = 2;
		// Clan marker blinks during overtime
		if (((Now - StartTime) / 500) % 3 == 2) {
			ClanMarkerColor = "";
		}
	}

	return """
		<frame posn="110 -65">
			<quad posn="0 0 0" sizen="55 8" halign="center" valign="center" style="Bgs1InRace" substyle="BgWindow{{{WindowStyle}}}" />
			<quad posn="-26 0 1" sizen="1 6" halign="center" valign="center" bgcolor="{{{ClanMarkerColor}}}c"/>
			<quad posn="26 0 1" sizen="1 6" halign="center" valign="center" bgcolor="{{{ClanMarkerColor}}}c"/>
			<label posn="0 0.5 2" sizen="50 7" halign="center" valign="center" textprefix="$000" text="{{{BallCarrierName}}}" />
		</frame>""";
}

// Update the extra layer
Text GetLayerExtra() {
	declare Manialink = """
		<script><!--
			main() {
				declare Quad_ForwardImage <=> (Page.GetFirstChild("Quad_ForwardImage") as CMlQuad);
				declare Quad_ForwardCheckBox <=> (Page.GetFirstChild("Quad_ForwardCheckBox") as CMlQuad);
				
				declare netread Net_ForwardClan for UI = 0;
				declare netwrite Net_ForwardSpawnOn for UI = False;
				
				while (True) {
					yield;
					
					if (Quad_ForwardImage != Null) {
						if (InputPlayer != Null && Net_ForwardClan == InputPlayer.CurrentClan) {
							Quad_ForwardImage.ImageUrl = "file://Media/Manialinks/Shootmania/Common/goal_cap.dds";
						} else {
							Quad_ForwardImage.ImageUrl = "file://Media/Manialinks/Shootmania/Common/goal.dds";
						}
					}
					
					if (Quad_ForwardCheckBox != Null) {
						if (Net_ForwardSpawnOn) {
							Quad_ForwardCheckBox.ImageUrl = "http://dl.dropbox.com/u/58886549/ManiaPlanet/Images/CheckBoxOn.png";
						} else {
							Quad_ForwardCheckBox.ImageUrl = "http://dl.dropbox.com/u/58886549/ManiaPlanet/Images/CheckBoxOff.png";
						}
					}
					
					foreach (Event in PendingEvents) {
						switch (Event.Type) {
							case CMlEvent::Type::MouseClick: {
								switch (Event.ControlId) {
									case "Quad_ForwardImage": {
										Net_ForwardSpawnOn = !Net_ForwardSpawnOn;
									}
									case "Quad_ForwardCheckBox": {
										Net_ForwardSpawnOn = !Net_ForwardSpawnOn;
									}
								}
							}
							case CMlEvent::Type::KeyPress: {
								switch (Event.CharPressed) {
									case "2555904": {
										Net_ForwardSpawnOn = !Net_ForwardSpawnOn;
									}
								}
							}
						}
					}
				}
			}
		--></script>""";
		
	// Forward info
	if (G_ForwardActive) {
		Manialink ^= """
			<frame posn="146 -65 5">
				<quad id="Quad_ForwardImage" sizen="6 6" colorize="1 1 1" halign="center" valign="center2"/>
				<quad id="Quad_ForwardCheckBox" posn="6 0" sizen="3 3" halign="center" valign="center2" scriptevents="1"/>
			</frame>""";
	}
	
	// Overtime note
	if (G_Overtime) {
		Manialink ^= """
			<label posn="0 66 99" halign="center" scale="0.9" textprefix="$f00$s$o" text="{{{T_Overtime}}}!"/>""";
	}
	
	return Manialink;
}

// Get top frame depending on style setting
Text GetFrameTop(Text _TopIdent, Text _Pos) {
	declare Title = """Top {{{C_TopCount}}} {{{_TopIdent}}}""";
	declare UnitType = "";
	switch (_TopIdent) {
		case T_Backstabber: {
			Title = """Flop {{{C_TopCount}}} {{{_TopIdent}}}""";
		}
	}
	if (C_UseNewTopStyle) {
		return Top::GetFrameTop2(_TopIdent, Title, _Pos, UnitType);
	}
	return Top::GetFrameTop(_TopIdent, Title, _Pos, UnitType);
}

// Update player position layer
Void UpdatePositionLayer(CSmPlayer _Player) {
	declare UI <=> UIManager.GetUI(_Player);
	if (UI != Null) {
		declare netwrite Net_LibInterface_LayerInfoUpdate for UI = 0;
		declare netwrite Net_LibInterface_PosTotal for UI = 0;
		declare netwrite Net_LibInterface_PosCurrent for UI = 0;
		
		Net_LibInterface_LayerInfoUpdate = Now;
		Net_LibInterface_PosTotal = Scores.count;
		Net_LibInterface_PosCurrent = Scores.keyof(_Player.Score) + 1;
	}
}

// Creates message for near miss
Text GetNearMissMessage(CSmModeEvent _Event) {
	// Catch invalid events
	if (_Event.Type != CSmModeEvent::EType::OnNearMiss) return "";	// Wrong event type
	if (_Event.MissDist <= 0.0) return "";							// Invalid miss distance
	
	// Get message text
	declare Message = "";
	declare Dist = MathLib::NearestInteger(_Event.MissDist * 1000);
	if (Dist >= 10) {
		Message = (Dist/10.0)^"cm!";
	} else {
		Dist = MathLib::NearestInteger(_Event.MissDist * 10000);
		if (Dist >= 10) {
			Message = (Dist/10.0)^"mm!";
		} else {
			Dist = MathLib::NearestInteger(_Event.MissDist * 10000000);
			Message = (Dist/10.0)^"µm!";
		}
	}
	return TextLib::Compose(_("You missed $<%1$> by %2"), _Event.Victim.Name, Message);
}

// Get the current rankings for xmlrpc callbacks
Text GetRankings() {
	declare PlayerList = "";
	foreach (Score in Scores) {
		PlayerList ^= Score.User.Login^":"^Score.Points^";";
	}
	return PlayerList;
}

// Update hud3dmarkers
Void UpdateHud3dMarkers() {
	// Marker strings
	declare Text Markers;
	
	// Spawn markers
	if (G_BallCarrierId != NullId && Players.existskey(G_BallCarrierId)) {
		if (!Players[G_BallCarrierId].IsFakePlayer) {
			// Normal player
			Markers = """<marker playerlogin="{{{Players[G_BallCarrierId].Login}}}" manialinkframeid="Frame_BallMarker"/>""";
		} else {
			// Bot
			Markers = """<marker pos="{{{Players[G_BallCarrierId].Position[0]}}} {{{Players[G_BallCarrierId].Position[1]}}} {{{Players[G_BallCarrierId].Position[2]}}}" manialinkframeid="Frame_BallMarker" box="0 1.6 0"/>""";
		}
	} else {
		Markers = """<marker pos="{{{G_BallDropPosition[0]}}} {{{G_BallDropPosition[1]}}} {{{G_BallDropPosition[2]}}}" manialinkframeid="Frame_BallMarker"/>""";
	}
	
	// Pole markers
	foreach (Pole in BlockPoles) {
		if (Pole.Order == 1 || Pole.Order == 2) {
			Markers ^= """<marker manialinkframeid="Frame_PoleMarker{{{Pole.Order}}}" pos="{{{Pole.Position[0]}}} {{{Pole.Position[1]}}} {{{Pole.Position[2]}}}" box="0 4 0"/>""";
		}
	}
	if (G_ForwardActive && G_ForwardGoalId != NullId && BlockPoles.existskey(G_ForwardGoalId)) {
		Markers ^= """<marker manialinkframeid="Frame_ForwardGoal" pos="{{{BlockPoles[G_ForwardGoalId].Position[0]}}} {{{BlockPoles[G_ForwardGoalId].Position[1]}}} {{{BlockPoles[G_ForwardGoalId].Position[2]}}}" box="0 9 0"/>""";
	}
	
	// Update markers
	UIManager.UIAll.Hud3dMarkers = Markers;
}

// Calculate the complementary color
Vec3 GetComplementaryColor(Vec3 _Color) {
	declare Vec3 Color;
	// Calculate each color channel
	for (Index, 0, 2) {
		Color[Index] = 1.0 - _Color[Index];
	}
	return Color;
}

Vec3 GetNeutralColor() {
	declare Color1 = Teams[0].ColorPrimary;
	declare Color2 = Teams[1].ColorPrimary;
	
	declare Vec3 Color;
	declare HighestValue = 0.0;
	// Calculate each color channel
	for (Index, 0, 2) {
		Color[Index] = (2.0 - Color1[Index] - Color2[Index]) / 2.0;
		if (Color[Index] > HighestValue) {
			HighestValue = Color[Index];
		}
	}
	// Upscale color channels to 1.0 for the highest
	if (HighestValue > 0.0) {
		// Calculate factor
		declare Factor = 1.0 / HighestValue;
		// Upscale channels
		for (Index, 0, 2) {
			Color[Index] *= Factor;
		}
	}
	return Color;
}

// Create markers layer
Text GetMarkersLayer() {
	// Get colored ball image
	declare Image = """ image="http://dl.dropbox.com/u/58886549/ManiaPlanet/Images/SpeedBall/SpeedBallGreen.png" """;
	declare Vec3 BallColor;
	if (G_BallCarrierId != NullId && Players.existskey(G_BallCarrierId) && Teams.existskey(Players[G_BallCarrierId].CurrentClan-1)) {
		BallColor = Teams[Players[G_BallCarrierId].CurrentClan-1].ColorPrimary;
	} else {
		BallColor = GetNeutralColor();
	}
	Image ^= """ colorize="{{{BallColor.X}}} {{{BallColor.Y}}} {{{BallColor.Z}}}" """;
	
	declare Manialink = """
		<script><!--
		main() {
			declare Label_BallMarker <=> (Page.GetFirstChild("Label_BallMarker") as CMlLabel);
			declare Quad_BallMarker <=> (Page.GetFirstChild("Quad_BallMarker") as CMlQuad);
			declare Label_PoleMarker1 <=> (Page.GetFirstChild("Label_PoleMarker1") as CMlLabel);
			declare Label_PoleMarker2 <=> (Page.GetFirstChild("Label_PoleMarker2") as CMlLabel);
			
			declare Ident[Integer] PoleIds;
			foreach (Pole in BlockPoles) {
				if (Pole.Order == 1 || Pole.Order == 2) {
					PoleIds[Pole.Order] = Pole.Id;
				}
			}
			
			declare netread Net_CurrentBallCarrierClan for UI = 0;
			declare netread Net_RemainingDropTime for UI = 0;
			
			declare LastUIUpdate = 0;
			
			while (True) {
				yield;
				
				if (LastUIUpdate + 200 < Now) {
					LastUIUpdate = Now;
					
					if (Net_CurrentBallCarrierClan == 0 && Net_RemainingDropTime > 0) {
						Label_BallMarker.Value = ""^(Net_RemainingDropTime/1000);
					} else {
						Label_BallMarker.Value = "";
					}
					
					if (InputPlayer != Null) {
						// Update pole markers
						foreach (Order => Id in PoleIds) {
							declare Tag = "";
							declare PoleClan = BlockPoles[Id].Gauge.Clan;
							if (Teams.existskey(PoleClan-1)) {
								Tag = Teams[PoleClan-1].ColorText;
								if (BlockPoles[Id].Gauge.Clan == InputPlayer.CurrentClan) {
									Tag ^= "Attack";
								} else {
									Tag ^= "Defend";
								}
							}
							switch (Order) {
								case 1: {
									Label_PoleMarker1.Value = Tag;
								}
								case 2: {
									Label_PoleMarker2.Value = Tag;
								}
							}
						}
					}
				}
			}
		}
		--></script>
		<frame id="Frame_BallMarker" hidden="1">
			<label id="Label_BallMarker" sizen="9 16" posn="0.2 5.9" halign="center" valign="bottom" scale="0.9" textprefix="${{{Color::RgbToHex(GetComplementaryColor(BallColor))}}}"/>
			<quad id="Quad_BallMarker" sizen="9 16" halign="center" valign="bottom" {{{Image}}}/>
		</frame>
		<frame id="Frame_PoleMarker1" hidden="1">
			<label id="Label_PoleMarker1" posn="0 4" textsize="2" scale="0.8" halign="center" valign="center2"/>
			<quad posn="0 4" sizen="11 4" halign="center" valign="center" style="BgsPlayerCard" substyle="BgMediaTracker"/>
		</frame>
		<frame id="Frame_PoleMarker2" hidden="1">
			<label id="Label_PoleMarker2" posn="0 4" textsize="2" scale="0.8" halign="center" valign="center2"/>
			<quad posn="0 4" sizen="11 4" halign="center" valign="center" style="BgsPlayerCard" substyle="BgMediaTracker"/>
		</frame>""";
	if (G_ForwardActive) {
		declare Vec3 GoalColor;
		if (G_ForwardClan != 0 && Teams.existskey(G_ForwardClan-1)) {
			GoalColor = Teams[G_ForwardClan-1].ColorPrimary;
		} else {
			GoalColor = GetNeutralColor();
		}
		
		Manialink ^= """
			<frame id="Frame_ForwardGoal" hidden="1">
				<quad posn="0 6" sizen="4.5 8" halign="center" valign="center" image="file://Media/Manialinks/Shootmania/Common/spawn.dds" colorize="{{{GoalColor.X}}} {{{GoalColor.Y}}} {{{GoalColor.Z}}}"/>
			</frame>""";
	}
	return Manialink;
}

// Resets values of all UIs
Void ResetUIs() {
	foreach (UI in UIManager.UI) {
		UI.BigMessage = "";
		UI.StatusMessage = "";
		UI.ManialinkPage = "";
		UI.Hud3dMarkers = "";
	}
}
